/* tslint:disable */
/* eslint-disable */
/**
 * Battery Data API
 * A standard API for accessing battery experiment datasets and metadata
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: martin.robinson@cs.ox.ac.uk
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * A ModelSerializer that maps unrecognised properties in the input to an \'additional_properties\' JSONField, and unpacks the \'additional_properties\' JSONField into the output.  The Meta.model must have an additional_properties JSONField.
 * @export
 * @interface Cell
 */
export interface Cell {
    /**
     * 
     * @type {string}
     * @memberof Cell
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof Cell
     */
    'uuid': string;
    /**
     * Unique identifier (e.g. serial number) for the cell
     * @type {string}
     * @memberof Cell
     */
    'identifier': string;
    /**
     * Cell Family this Cell belongs to
     * @type {string}
     * @memberof Cell
     */
    'family': string;
    /**
     * Cycler Tests using this Cell
     * @type {Array<string>}
     * @memberof Cell
     */
    'cycler_tests': Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof Cell
     */
    'in_use': boolean;
    /**
     * Team this resource belongs to
     * @type {string}
     * @memberof Cell
     */
    'team': string;
    /**
     * 
     * @type {CellPermissions}
     * @memberof Cell
     */
    'permissions': CellPermissions;
}
/**
 * 
 * @export
 * @interface CellChemistriesList200Response
 */
export interface CellChemistriesList200Response {
    /**
     * 
     * @type {number}
     * @memberof CellChemistriesList200Response
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof CellChemistriesList200Response
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CellChemistriesList200Response
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof CellChemistriesList200Response
     */
    'results'?: Array<string>;
}
/**
 * A ModelSerializer that maps unrecognised properties in the input to an \'additional_properties\' JSONField, and unpacks the \'additional_properties\' JSONField into the output.  The Meta.model must have an additional_properties JSONField.
 * @export
 * @interface CellFamily
 */
export interface CellFamily {
    /**
     * 
     * @type {string}
     * @memberof CellFamily
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof CellFamily
     */
    'uuid': string;
    /**
     * Manufacturer name
     * @type {string}
     * @memberof CellFamily
     */
    'manufacturer': string;
    /**
     * Model number
     * @type {string}
     * @memberof CellFamily
     */
    'model': string;
    /**
     * Link to the datasheet
     * @type {string}
     * @memberof CellFamily
     */
    'datasheet'?: string | null;
    /**
     * Chemistry type
     * @type {string}
     * @memberof CellFamily
     */
    'chemistry': string;
    /**
     * Nominal voltage of the cells (in volts)
     * @type {number}
     * @memberof CellFamily
     */
    'nominal_voltage'?: number | null;
    /**
     * Nominal capacity of the cells (in amp hours)
     * @type {number}
     * @memberof CellFamily
     */
    'nominal_capacity'?: number | null;
    /**
     * Initial AC impedance of the cells (in ohms)
     * @type {number}
     * @memberof CellFamily
     */
    'initial_ac_impedance'?: number | null;
    /**
     * Initial DC resistance of the cells (in ohms)
     * @type {number}
     * @memberof CellFamily
     */
    'initial_dc_resistance'?: number | null;
    /**
     * Energy density of the cells (in watt hours per kilogram)
     * @type {number}
     * @memberof CellFamily
     */
    'energy_density'?: number | null;
    /**
     * Power density of the cells (in watts per kilogram)
     * @type {number}
     * @memberof CellFamily
     */
    'power_density'?: number | null;
    /**
     * Physical form factor
     * @type {string}
     * @memberof CellFamily
     */
    'form_factor': string;
    /**
     * Cells belonging to this Cell Family
     * @type {Array<string>}
     * @memberof CellFamily
     */
    'cells': Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof CellFamily
     */
    'in_use': boolean;
    /**
     * Team this resource belongs to
     * @type {string}
     * @memberof CellFamily
     */
    'team': string;
    /**
     * 
     * @type {CellPermissions}
     * @memberof CellFamily
     */
    'permissions': CellPermissions;
}
/**
 * 
 * @export
 * @interface CellPermissions
 */
export interface CellPermissions {
    /**
     * 
     * @type {boolean}
     * @memberof CellPermissions
     */
    'read'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CellPermissions
     */
    'write'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CellPermissions
     */
    'create'?: boolean;
}
/**
 * 
 * @export
 * @interface CreateKnoxToken
 */
export interface CreateKnoxToken {
    /**
     * Time to live (s)
     * @type {number}
     * @memberof CreateKnoxToken
     */
    'ttl'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateKnoxToken
     */
    'name': string;
}
/**
 * A ModelSerializer that maps unrecognised properties in the input to an \'additional_properties\' JSONField, and unpacks the \'additional_properties\' JSONField into the output.  The Meta.model must have an additional_properties JSONField.
 * @export
 * @interface CyclerTest
 */
export interface CyclerTest {
    /**
     * 
     * @type {string}
     * @memberof CyclerTest
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof CyclerTest
     */
    'uuid': string;
    /**
     * Cell this Cycler Test uses
     * @type {string}
     * @memberof CyclerTest
     */
    'cell_subject': string;
    /**
     * Equipment this Cycler Test uses
     * @type {Array<string>}
     * @memberof CyclerTest
     */
    'equipment': Array<string>;
    /**
     * Schedule this Cycler Test uses
     * @type {string}
     * @memberof CyclerTest
     */
    'schedule': string;
    /**
     * Rendered schedule
     * @type {string}
     * @memberof CyclerTest
     */
    'rendered_schedule': string | null;
    /**
     * Team this resource belongs to
     * @type {string}
     * @memberof CyclerTest
     */
    'team': string;
    /**
     * 
     * @type {CellPermissions}
     * @memberof CyclerTest
     */
    'permissions': CellPermissions;
}
/**
 * A column contains metadata and data. Data are an ordered list of values.
 * @export
 * @interface DataColumn
 */
export interface DataColumn {
    /**
     * Auto-assigned object identifier
     * @type {number}
     * @memberof DataColumn
     */
    'id': number;
    /**
     * Canonical URL for this object
     * @type {string}
     * @memberof DataColumn
     */
    'url': string;
    /**
     * Column name (assigned by harvester but overridden by Galv for core fields)
     * @type {string}
     * @memberof DataColumn
     */
    'name': string;
    /**
     * Column title e.g. in .tsv file headers
     * @type {string}
     * @memberof DataColumn
     */
    'name_in_file': string;
    /**
     * Whether the column is one of those required by Galv
     * @type {boolean}
     * @memberof DataColumn
     */
    'is_required_column': boolean;
    /**
     * File this Column belongs to
     * @type {string}
     * @memberof DataColumn
     */
    'file': string;
    /**
     * Type of the data in this column
     * @type {string}
     * @memberof DataColumn
     */
    'data_type': string;
    /**
     * Human-friendly identifier
     * @type {string}
     * @memberof DataColumn
     */
    'type_name': string;
    /**
     * Origins and purpose
     * @type {string}
     * @memberof DataColumn
     */
    'description': string;
    /**
     * Unit used for measuring the values in this column
     * @type {{ [key: string]: string; }}
     * @memberof DataColumn
     */
    'unit': { [key: string]: string; } | null;
    /**
     * Column values
     * @type {string}
     * @memberof DataColumn
     */
    'values': string;
    /**
     * 
     * @type {CellPermissions}
     * @memberof DataColumn
     */
    'permissions': CellPermissions;
}
/**
 * 
 * @export
 * @interface DataColumnType
 */
export interface DataColumnType {
    /**
     * Canonical URL for this object
     * @type {string}
     * @memberof DataColumnType
     */
    'url': string;
    /**
     * Auto-assigned object identifier
     * @type {number}
     * @memberof DataColumnType
     */
    'id': number;
    /**
     * Human-friendly identifier
     * @type {string}
     * @memberof DataColumnType
     */
    'name': string;
    /**
     * Origins and purpose
     * @type {string}
     * @memberof DataColumnType
     */
    'description': string;
    /**
     * Whether the Column is included in the initial list of known Column Types
     * @type {boolean}
     * @memberof DataColumnType
     */
    'is_default'?: boolean;
    /**
     * Unit used for measuring the values in this column
     * @type {string}
     * @memberof DataColumnType
     */
    'unit': string | null;
    /**
     * 
     * @type {CellPermissions}
     * @memberof DataColumnType
     */
    'permissions': CellPermissions;
}
/**
 * 
 * @export
 * @interface DataUnit
 */
export interface DataUnit {
    /**
     * Canonical URL for this object
     * @type {string}
     * @memberof DataUnit
     */
    'url': string;
    /**
     * Auto-assigned object identifier
     * @type {number}
     * @memberof DataUnit
     */
    'id': number;
    /**
     * Common name
     * @type {string}
     * @memberof DataUnit
     */
    'name': string;
    /**
     * Symbol
     * @type {string}
     * @memberof DataUnit
     */
    'symbol': string;
    /**
     * What the Unit signifies, and how it is used
     * @type {string}
     * @memberof DataUnit
     */
    'description': string;
    /**
     * 
     * @type {CellPermissions}
     * @memberof DataUnit
     */
    'permissions': CellPermissions;
}
/**
 * A ModelSerializer that maps unrecognised properties in the input to an \'additional_properties\' JSONField, and unpacks the \'additional_properties\' JSONField into the output.  The Meta.model must have an additional_properties JSONField.
 * @export
 * @interface Equipment
 */
export interface Equipment {
    /**
     * 
     * @type {string}
     * @memberof Equipment
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof Equipment
     */
    'uuid': string;
    /**
     * Unique identifier (e.g. serial number) for the equipment
     * @type {string}
     * @memberof Equipment
     */
    'identifier': string;
    /**
     * Equipment Family this Equipment belongs to
     * @type {string}
     * @memberof Equipment
     */
    'family': string;
    /**
     * Date of last calibration
     * @type {string}
     * @memberof Equipment
     */
    'calibration_date'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Equipment
     */
    'in_use': boolean;
    /**
     * Team this resource belongs to
     * @type {string}
     * @memberof Equipment
     */
    'team': string;
    /**
     * Cycler Tests using this Equipment
     * @type {Array<string>}
     * @memberof Equipment
     */
    'cycler_tests': Array<string>;
    /**
     * 
     * @type {CellPermissions}
     * @memberof Equipment
     */
    'permissions': CellPermissions;
}
/**
 * A ModelSerializer that maps unrecognised properties in the input to an \'additional_properties\' JSONField, and unpacks the \'additional_properties\' JSONField into the output.  The Meta.model must have an additional_properties JSONField.
 * @export
 * @interface EquipmentFamily
 */
export interface EquipmentFamily {
    /**
     * 
     * @type {string}
     * @memberof EquipmentFamily
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof EquipmentFamily
     */
    'uuid': string;
    /**
     * Equipment type
     * @type {string}
     * @memberof EquipmentFamily
     */
    'type': string;
    /**
     * Manufacturer name
     * @type {string}
     * @memberof EquipmentFamily
     */
    'manufacturer': string;
    /**
     * Model number
     * @type {string}
     * @memberof EquipmentFamily
     */
    'model': string;
    /**
     * 
     * @type {boolean}
     * @memberof EquipmentFamily
     */
    'in_use': boolean;
    /**
     * Team this resource belongs to
     * @type {string}
     * @memberof EquipmentFamily
     */
    'team': string;
    /**
     * Equipment belonging to this Equipment Family
     * @type {Array<string>}
     * @memberof EquipmentFamily
     */
    'equipment': Array<string>;
    /**
     * 
     * @type {CellPermissions}
     * @memberof EquipmentFamily
     */
    'permissions': CellPermissions;
}
/**
 * 
 * @export
 * @interface Experiment
 */
export interface Experiment {
    /**
     * Canonical URL for this object
     * @type {string}
     * @memberof Experiment
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof Experiment
     */
    'uuid': string;
    /**
     * Title of the experiment
     * @type {string}
     * @memberof Experiment
     */
    'title': string;
    /**
     * Description of the experiment
     * @type {string}
     * @memberof Experiment
     */
    'description'?: string | null;
    /**
     * Users who created this Experiment
     * @type {Array<string>}
     * @memberof Experiment
     */
    'authors': Array<string>;
    /**
     * Protocol of the experiment
     * @type {{ [key: string]: any; }}
     * @memberof Experiment
     */
    'protocol'?: { [key: string]: any; } | null;
    /**
     * Protocol file of the experiment
     * @type {string}
     * @memberof Experiment
     */
    'protocol_file'?: string | null;
    /**
     * Cycler Tests using this Experiment
     * @type {Array<string>}
     * @memberof Experiment
     */
    'cycler_tests': Array<string>;
    /**
     * Team this resource belongs to
     * @type {string}
     * @memberof Experiment
     */
    'team': string;
    /**
     * 
     * @type {CellPermissions}
     * @memberof Experiment
     */
    'permissions': CellPermissions;
}
/**
 * 
 * @export
 * @interface Group
 */
export interface Group {
    /**
     * 
     * @type {number}
     * @memberof Group
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'name': string;
    /**
     * Users in the group
     * @type {Array<string>}
     * @memberof Group
     */
    'users': Array<string>;
    /**
     * 
     * @type {CellPermissions}
     * @memberof Group
     */
    'permissions': CellPermissions;
    /**
     * Users to add
     * @type {Array<string>}
     * @memberof Group
     */
    'add_users'?: Array<string>;
    /**
     * Users to remove
     * @type {Array<string>}
     * @memberof Group
     */
    'remove_users'?: Array<string>;
}
/**
 * 
 * @export
 * @interface HarvestError
 */
export interface HarvestError {
    /**
     * Canonical URL for this object
     * @type {string}
     * @memberof HarvestError
     */
    'url': string;
    /**
     * Auto-assigned object identifier
     * @type {number}
     * @memberof HarvestError
     */
    'id': number;
    /**
     * Harvester this HarvestError belongs to
     * @type {string}
     * @memberof HarvestError
     */
    'harvester': string;
    /**
     * File this HarvestError belongs to
     * @type {string}
     * @memberof HarvestError
     */
    'file': string;
    /**
     * Text of the error report
     * @type {string}
     * @memberof HarvestError
     */
    'error': string;
    /**
     * Date and time error was logged in the database
     * @type {string}
     * @memberof HarvestError
     */
    'timestamp': string | null;
    /**
     * 
     * @type {CellPermissions}
     * @memberof HarvestError
     */
    'permissions': CellPermissions;
}
/**
 * 
 * @export
 * @interface Harvester
 */
export interface Harvester {
    /**
     * Canonical URL for this object
     * @type {string}
     * @memberof Harvester
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof Harvester
     */
    'uuid': string;
    /**
     * Date and time of last Harvester contact
     * @type {string}
     * @memberof Harvester
     */
    'last_check_in': string | null;
    /**
     * Lab this Harvester belongs to
     * @type {string}
     * @memberof Harvester
     */
    'lab': string;
    /**
     * 
     * @type {CellPermissions}
     * @memberof Harvester
     */
    'permissions': CellPermissions;
    /**
     * Human-friendly Harvester identifier
     * @type {string}
     * @memberof Harvester
     */
    'name': string;
    /**
     * Seconds to sleep between Harvester cycles
     * @type {number}
     * @memberof Harvester
     */
    'sleep_time'?: number;
    /**
     * Environment variables set on this Harvester
     * @type {{ [key: string]: any; }}
     * @memberof Harvester
     */
    'environment_variables': { [key: string]: any; };
    /**
     * Whether the Harvester is active
     * @type {boolean}
     * @memberof Harvester
     */
    'active'?: boolean;
}
/**
 * 
 * @export
 * @interface KnoxToken
 */
export interface KnoxToken {
    /**
     * Canonical URL for this object
     * @type {string}
     * @memberof KnoxToken
     */
    'url': string;
    /**
     * Auto-assigned object identifier
     * @type {number}
     * @memberof KnoxToken
     */
    'id': number;
    /**
     * Convenient human-friendly name
     * @type {string}
     * @memberof KnoxToken
     */
    'name': string;
    /**
     * Date and time of creation
     * @type {string}
     * @memberof KnoxToken
     */
    'created': string;
    /**
     * Date and time token expires (blank = never)
     * @type {string}
     * @memberof KnoxToken
     */
    'expiry': string | null;
}
/**
 * 
 * @export
 * @interface KnoxTokenFull
 */
export interface KnoxTokenFull {
    /**
     * Canonical URL for this object
     * @type {string}
     * @memberof KnoxTokenFull
     */
    'url': string;
    /**
     * Auto-assigned object identifier
     * @type {number}
     * @memberof KnoxTokenFull
     */
    'id': number;
    /**
     * Convenient human-friendly name
     * @type {string}
     * @memberof KnoxTokenFull
     */
    'name': string;
    /**
     * Date and time of creation
     * @type {string}
     * @memberof KnoxTokenFull
     */
    'created': string;
    /**
     * Date and time token expires (blank = never)
     * @type {string}
     * @memberof KnoxTokenFull
     */
    'expiry': string | null;
    /**
     * Token value
     * @type {string}
     * @memberof KnoxTokenFull
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface KnoxUser
 */
export interface KnoxUser {
    /**
     * 
     * @type {string}
     * @memberof KnoxUser
     */
    'expiry': string;
    /**
     * 
     * @type {string}
     * @memberof KnoxUser
     */
    'token': string;
    /**
     * 
     * @type {User}
     * @memberof KnoxUser
     */
    'user': User;
}
/**
 * 
 * @export
 * @interface Lab
 */
export interface Lab {
    /**
     * 
     * @type {string}
     * @memberof Lab
     */
    'url': string;
    /**
     * 
     * @type {number}
     * @memberof Lab
     */
    'id': number;
    /**
     * Human-friendly Lab identifier
     * @type {string}
     * @memberof Lab
     */
    'name': string;
    /**
     * Description of the Lab
     * @type {string}
     * @memberof Lab
     */
    'description'?: string | null;
    /**
     * 
     * @type {LabAdminGroup}
     * @memberof Lab
     */
    'admin_group': LabAdminGroup;
    /**
     * Teams in this Lab
     * @type {Array<string>}
     * @memberof Lab
     */
    'teams': Array<string>;
    /**
     * 
     * @type {CellPermissions}
     * @memberof Lab
     */
    'permissions': CellPermissions;
}
/**
 * Group of users who can edit this Lab
 * @export
 * @interface LabAdminGroup
 */
export interface LabAdminGroup {
    /**
     * 
     * @type {number}
     * @memberof LabAdminGroup
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof LabAdminGroup
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof LabAdminGroup
     */
    'name': string;
    /**
     * Users in the group
     * @type {Array<string>}
     * @memberof LabAdminGroup
     */
    'users': Array<string>;
    /**
     * 
     * @type {CellPermissions}
     * @memberof LabAdminGroup
     */
    'permissions': CellPermissions;
    /**
     * Users to add
     * @type {Array<string>}
     * @memberof LabAdminGroup
     */
    'add_users'?: Array<string>;
    /**
     * Users to remove
     * @type {Array<string>}
     * @memberof LabAdminGroup
     */
    'remove_users'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * Description of the error
     * @type {string}
     * @memberof ModelError
     */
    'error': string;
}
/**
 * 
 * @export
 * @interface MonitoredPath
 */
export interface MonitoredPath {
    /**
     * Canonical URL for this object
     * @type {string}
     * @memberof MonitoredPath
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof MonitoredPath
     */
    'uuid': string;
    /**
     * Directory location on Harvester
     * @type {string}
     * @memberof MonitoredPath
     */
    'path': string;
    /**
     *      Python.re regular expression to filter files by,      applied to full file name starting from this Path\'s directory
     * @type {string}
     * @memberof MonitoredPath
     */
    'regex': string | null;
    /**
     * Number of seconds files must remain stable to be processed
     * @type {number}
     * @memberof MonitoredPath
     */
    'stable_time'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof MonitoredPath
     */
    'active'?: boolean;
    /**
     * Harvester this MonitoredPath belongs to
     * @type {string}
     * @memberof MonitoredPath
     */
    'harvester': string;
    /**
     * Team this resource belongs to
     * @type {string}
     * @memberof MonitoredPath
     */
    'team': string;
    /**
     * 
     * @type {CellPermissions}
     * @memberof MonitoredPath
     */
    'permissions': CellPermissions;
}
/**
 * 
 * @export
 * @interface ObservedFile
 */
export interface ObservedFile {
    /**
     * Canonical URL for this object
     * @type {string}
     * @memberof ObservedFile
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof ObservedFile
     */
    'uuid': string;
    /**
     * Harvester this File belongs to
     * @type {string}
     * @memberof ObservedFile
     */
    'harvester': string;
    /**
     * Absolute file path
     * @type {string}
     * @memberof ObservedFile
     */
    'path': string;
    /**
     * File status; autogenerated but can be manually set to RETRY IMPORT
     * @type {string}
     * @memberof ObservedFile
     */
    'state': ObservedFileStateEnum;
    /**
     * Parser used by the harvester
     * @type {string}
     * @memberof ObservedFile
     */
    'parser': string | null;
    /**
     * Number of rows in the file
     * @type {number}
     * @memberof ObservedFile
     */
    'num_rows': number | null;
    /**
     * Number of the first sample in the file
     * @type {number}
     * @memberof ObservedFile
     */
    'first_sample_no': number | null;
    /**
     * Number of the last sample in the file
     * @type {number}
     * @memberof ObservedFile
     */
    'last_sample_no': number | null;
    /**
     * Extra metadata from the harvester
     * @type {{ [key: string]: any; }}
     * @memberof ObservedFile
     */
    'extra_metadata': { [key: string]: any; } | null;
    /**
     * Whether the file has all required columns
     * @type {boolean}
     * @memberof ObservedFile
     */
    'has_required_columns': boolean;
    /**
     * Date and time of last Harvester report on file
     * @type {string}
     * @memberof ObservedFile
     */
    'last_observed_time': string | null;
    /**
     * Size of the file as last reported by Harvester
     * @type {number}
     * @memberof ObservedFile
     */
    'last_observed_size': number;
    /**
     * Errors associated with this File
     * @type {Array<string>}
     * @memberof ObservedFile
     */
    'upload_errors': Array<string>;
    /**
     * Errors in uploaded columns
     * @type {Array<any>}
     * @memberof ObservedFile
     */
    'column_errors': Array<any>;
    /**
     * Metadata required for harvester program to resume file parsing
     * @type {{ [key: string]: any; }}
     * @memberof ObservedFile
     */
    'upload_info': { [key: string]: any; } | null;
    /**
     * Columns extracted from this File
     * @type {Array<string>}
     * @memberof ObservedFile
     */
    'columns': Array<string>;
    /**
     * 
     * @type {CellPermissions}
     * @memberof ObservedFile
     */
    'permissions': CellPermissions;
    /**
     * Name of the file
     * @type {string}
     * @memberof ObservedFile
     */
    'name'?: string | null;
}

export const ObservedFileStateEnum = {
    RetryImport: 'RETRY IMPORT',
    ImportFailed: 'IMPORT FAILED',
    Unstable: 'UNSTABLE',
    Growing: 'GROWING',
    Stable: 'STABLE',
    Importing: 'IMPORTING',
    Imported: 'IMPORTED'
} as const;

export type ObservedFileStateEnum = typeof ObservedFileStateEnum[keyof typeof ObservedFileStateEnum];

/**
 * 
 * @export
 * @interface PaginatedCellFamilyList
 */
export interface PaginatedCellFamilyList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedCellFamilyList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedCellFamilyList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedCellFamilyList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<CellFamily>}
     * @memberof PaginatedCellFamilyList
     */
    'results'?: Array<CellFamily>;
}
/**
 * 
 * @export
 * @interface PaginatedCellList
 */
export interface PaginatedCellList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedCellList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedCellList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedCellList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Cell>}
     * @memberof PaginatedCellList
     */
    'results'?: Array<Cell>;
}
/**
 * 
 * @export
 * @interface PaginatedCyclerTestList
 */
export interface PaginatedCyclerTestList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedCyclerTestList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedCyclerTestList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedCyclerTestList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<CyclerTest>}
     * @memberof PaginatedCyclerTestList
     */
    'results'?: Array<CyclerTest>;
}
/**
 * 
 * @export
 * @interface PaginatedDataColumnList
 */
export interface PaginatedDataColumnList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedDataColumnList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedDataColumnList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedDataColumnList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<DataColumn>}
     * @memberof PaginatedDataColumnList
     */
    'results'?: Array<DataColumn>;
}
/**
 * 
 * @export
 * @interface PaginatedDataColumnTypeList
 */
export interface PaginatedDataColumnTypeList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedDataColumnTypeList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedDataColumnTypeList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedDataColumnTypeList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<DataColumnType>}
     * @memberof PaginatedDataColumnTypeList
     */
    'results'?: Array<DataColumnType>;
}
/**
 * 
 * @export
 * @interface PaginatedDataUnitList
 */
export interface PaginatedDataUnitList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedDataUnitList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedDataUnitList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedDataUnitList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<DataUnit>}
     * @memberof PaginatedDataUnitList
     */
    'results'?: Array<DataUnit>;
}
/**
 * 
 * @export
 * @interface PaginatedEquipmentFamilyList
 */
export interface PaginatedEquipmentFamilyList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedEquipmentFamilyList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedEquipmentFamilyList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedEquipmentFamilyList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<EquipmentFamily>}
     * @memberof PaginatedEquipmentFamilyList
     */
    'results'?: Array<EquipmentFamily>;
}
/**
 * 
 * @export
 * @interface PaginatedEquipmentList
 */
export interface PaginatedEquipmentList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedEquipmentList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedEquipmentList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedEquipmentList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Equipment>}
     * @memberof PaginatedEquipmentList
     */
    'results'?: Array<Equipment>;
}
/**
 * 
 * @export
 * @interface PaginatedExperimentList
 */
export interface PaginatedExperimentList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedExperimentList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedExperimentList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedExperimentList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Experiment>}
     * @memberof PaginatedExperimentList
     */
    'results'?: Array<Experiment>;
}
/**
 * 
 * @export
 * @interface PaginatedGroupList
 */
export interface PaginatedGroupList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedGroupList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedGroupList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedGroupList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Group>}
     * @memberof PaginatedGroupList
     */
    'results'?: Array<Group>;
}
/**
 * 
 * @export
 * @interface PaginatedHarvestErrorList
 */
export interface PaginatedHarvestErrorList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedHarvestErrorList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedHarvestErrorList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedHarvestErrorList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<HarvestError>}
     * @memberof PaginatedHarvestErrorList
     */
    'results'?: Array<HarvestError>;
}
/**
 * 
 * @export
 * @interface PaginatedHarvesterList
 */
export interface PaginatedHarvesterList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedHarvesterList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedHarvesterList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedHarvesterList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Harvester>}
     * @memberof PaginatedHarvesterList
     */
    'results'?: Array<Harvester>;
}
/**
 * 
 * @export
 * @interface PaginatedKnoxTokenList
 */
export interface PaginatedKnoxTokenList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedKnoxTokenList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedKnoxTokenList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedKnoxTokenList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<KnoxToken>}
     * @memberof PaginatedKnoxTokenList
     */
    'results'?: Array<KnoxToken>;
}
/**
 * 
 * @export
 * @interface PaginatedLabList
 */
export interface PaginatedLabList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedLabList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedLabList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedLabList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Lab>}
     * @memberof PaginatedLabList
     */
    'results'?: Array<Lab>;
}
/**
 * 
 * @export
 * @interface PaginatedMonitoredPathList
 */
export interface PaginatedMonitoredPathList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedMonitoredPathList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedMonitoredPathList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedMonitoredPathList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<MonitoredPath>}
     * @memberof PaginatedMonitoredPathList
     */
    'results'?: Array<MonitoredPath>;
}
/**
 * 
 * @export
 * @interface PaginatedObservedFileList
 */
export interface PaginatedObservedFileList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedObservedFileList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedObservedFileList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedObservedFileList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<ObservedFile>}
     * @memberof PaginatedObservedFileList
     */
    'results'?: Array<ObservedFile>;
}
/**
 * 
 * @export
 * @interface PaginatedScheduleFamilyList
 */
export interface PaginatedScheduleFamilyList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedScheduleFamilyList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedScheduleFamilyList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedScheduleFamilyList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<ScheduleFamily>}
     * @memberof PaginatedScheduleFamilyList
     */
    'results'?: Array<ScheduleFamily>;
}
/**
 * 
 * @export
 * @interface PaginatedScheduleList
 */
export interface PaginatedScheduleList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedScheduleList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedScheduleList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedScheduleList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Schedule>}
     * @memberof PaginatedScheduleList
     */
    'results'?: Array<Schedule>;
}
/**
 * 
 * @export
 * @interface PaginatedTeamList
 */
export interface PaginatedTeamList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedTeamList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedTeamList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedTeamList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Team>}
     * @memberof PaginatedTeamList
     */
    'results'?: Array<Team>;
}
/**
 * 
 * @export
 * @interface PaginatedUserList
 */
export interface PaginatedUserList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedUserList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUserList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUserList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<User>}
     * @memberof PaginatedUserList
     */
    'results'?: Array<User>;
}
/**
 * 
 * @export
 * @interface PaginatedValidationSchemaList
 */
export interface PaginatedValidationSchemaList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedValidationSchemaList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedValidationSchemaList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedValidationSchemaList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<ValidationSchema>}
     * @memberof PaginatedValidationSchemaList
     */
    'results'?: Array<ValidationSchema>;
}
/**
 * A ModelSerializer that maps unrecognised properties in the input to an \'additional_properties\' JSONField, and unpacks the \'additional_properties\' JSONField into the output.  The Meta.model must have an additional_properties JSONField.
 * @export
 * @interface PatchedCell
 */
export interface PatchedCell {
    /**
     * 
     * @type {string}
     * @memberof PatchedCell
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedCell
     */
    'uuid'?: string;
    /**
     * Unique identifier (e.g. serial number) for the cell
     * @type {string}
     * @memberof PatchedCell
     */
    'identifier'?: string;
    /**
     * Cell Family this Cell belongs to
     * @type {string}
     * @memberof PatchedCell
     */
    'family'?: string;
    /**
     * Cycler Tests using this Cell
     * @type {Array<string>}
     * @memberof PatchedCell
     */
    'cycler_tests'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedCell
     */
    'in_use'?: boolean;
    /**
     * Team this resource belongs to
     * @type {string}
     * @memberof PatchedCell
     */
    'team'?: string;
    /**
     * 
     * @type {CellPermissions}
     * @memberof PatchedCell
     */
    'permissions'?: CellPermissions;
}
/**
 * A ModelSerializer that maps unrecognised properties in the input to an \'additional_properties\' JSONField, and unpacks the \'additional_properties\' JSONField into the output.  The Meta.model must have an additional_properties JSONField.
 * @export
 * @interface PatchedCellFamily
 */
export interface PatchedCellFamily {
    /**
     * 
     * @type {string}
     * @memberof PatchedCellFamily
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedCellFamily
     */
    'uuid'?: string;
    /**
     * Manufacturer name
     * @type {string}
     * @memberof PatchedCellFamily
     */
    'manufacturer'?: string;
    /**
     * Model number
     * @type {string}
     * @memberof PatchedCellFamily
     */
    'model'?: string;
    /**
     * Link to the datasheet
     * @type {string}
     * @memberof PatchedCellFamily
     */
    'datasheet'?: string | null;
    /**
     * Chemistry type
     * @type {string}
     * @memberof PatchedCellFamily
     */
    'chemistry'?: string;
    /**
     * Nominal voltage of the cells (in volts)
     * @type {number}
     * @memberof PatchedCellFamily
     */
    'nominal_voltage'?: number | null;
    /**
     * Nominal capacity of the cells (in amp hours)
     * @type {number}
     * @memberof PatchedCellFamily
     */
    'nominal_capacity'?: number | null;
    /**
     * Initial AC impedance of the cells (in ohms)
     * @type {number}
     * @memberof PatchedCellFamily
     */
    'initial_ac_impedance'?: number | null;
    /**
     * Initial DC resistance of the cells (in ohms)
     * @type {number}
     * @memberof PatchedCellFamily
     */
    'initial_dc_resistance'?: number | null;
    /**
     * Energy density of the cells (in watt hours per kilogram)
     * @type {number}
     * @memberof PatchedCellFamily
     */
    'energy_density'?: number | null;
    /**
     * Power density of the cells (in watts per kilogram)
     * @type {number}
     * @memberof PatchedCellFamily
     */
    'power_density'?: number | null;
    /**
     * Physical form factor
     * @type {string}
     * @memberof PatchedCellFamily
     */
    'form_factor'?: string;
    /**
     * Cells belonging to this Cell Family
     * @type {Array<string>}
     * @memberof PatchedCellFamily
     */
    'cells'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedCellFamily
     */
    'in_use'?: boolean;
    /**
     * Team this resource belongs to
     * @type {string}
     * @memberof PatchedCellFamily
     */
    'team'?: string;
    /**
     * 
     * @type {CellPermissions}
     * @memberof PatchedCellFamily
     */
    'permissions'?: CellPermissions;
}
/**
 * A ModelSerializer that maps unrecognised properties in the input to an \'additional_properties\' JSONField, and unpacks the \'additional_properties\' JSONField into the output.  The Meta.model must have an additional_properties JSONField.
 * @export
 * @interface PatchedCyclerTest
 */
export interface PatchedCyclerTest {
    /**
     * 
     * @type {string}
     * @memberof PatchedCyclerTest
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedCyclerTest
     */
    'uuid'?: string;
    /**
     * Cell this Cycler Test uses
     * @type {string}
     * @memberof PatchedCyclerTest
     */
    'cell_subject'?: string;
    /**
     * Equipment this Cycler Test uses
     * @type {Array<string>}
     * @memberof PatchedCyclerTest
     */
    'equipment'?: Array<string>;
    /**
     * Schedule this Cycler Test uses
     * @type {string}
     * @memberof PatchedCyclerTest
     */
    'schedule'?: string;
    /**
     * Rendered schedule
     * @type {string}
     * @memberof PatchedCyclerTest
     */
    'rendered_schedule'?: string | null;
    /**
     * Team this resource belongs to
     * @type {string}
     * @memberof PatchedCyclerTest
     */
    'team'?: string;
    /**
     * 
     * @type {CellPermissions}
     * @memberof PatchedCyclerTest
     */
    'permissions'?: CellPermissions;
}
/**
 * A ModelSerializer that maps unrecognised properties in the input to an \'additional_properties\' JSONField, and unpacks the \'additional_properties\' JSONField into the output.  The Meta.model must have an additional_properties JSONField.
 * @export
 * @interface PatchedEquipment
 */
export interface PatchedEquipment {
    /**
     * 
     * @type {string}
     * @memberof PatchedEquipment
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedEquipment
     */
    'uuid'?: string;
    /**
     * Unique identifier (e.g. serial number) for the equipment
     * @type {string}
     * @memberof PatchedEquipment
     */
    'identifier'?: string;
    /**
     * Equipment Family this Equipment belongs to
     * @type {string}
     * @memberof PatchedEquipment
     */
    'family'?: string;
    /**
     * Date of last calibration
     * @type {string}
     * @memberof PatchedEquipment
     */
    'calibration_date'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedEquipment
     */
    'in_use'?: boolean;
    /**
     * Team this resource belongs to
     * @type {string}
     * @memberof PatchedEquipment
     */
    'team'?: string;
    /**
     * Cycler Tests using this Equipment
     * @type {Array<string>}
     * @memberof PatchedEquipment
     */
    'cycler_tests'?: Array<string>;
    /**
     * 
     * @type {CellPermissions}
     * @memberof PatchedEquipment
     */
    'permissions'?: CellPermissions;
}
/**
 * A ModelSerializer that maps unrecognised properties in the input to an \'additional_properties\' JSONField, and unpacks the \'additional_properties\' JSONField into the output.  The Meta.model must have an additional_properties JSONField.
 * @export
 * @interface PatchedEquipmentFamily
 */
export interface PatchedEquipmentFamily {
    /**
     * 
     * @type {string}
     * @memberof PatchedEquipmentFamily
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedEquipmentFamily
     */
    'uuid'?: string;
    /**
     * Equipment type
     * @type {string}
     * @memberof PatchedEquipmentFamily
     */
    'type'?: string;
    /**
     * Manufacturer name
     * @type {string}
     * @memberof PatchedEquipmentFamily
     */
    'manufacturer'?: string;
    /**
     * Model number
     * @type {string}
     * @memberof PatchedEquipmentFamily
     */
    'model'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedEquipmentFamily
     */
    'in_use'?: boolean;
    /**
     * Team this resource belongs to
     * @type {string}
     * @memberof PatchedEquipmentFamily
     */
    'team'?: string;
    /**
     * Equipment belonging to this Equipment Family
     * @type {Array<string>}
     * @memberof PatchedEquipmentFamily
     */
    'equipment'?: Array<string>;
    /**
     * 
     * @type {CellPermissions}
     * @memberof PatchedEquipmentFamily
     */
    'permissions'?: CellPermissions;
}
/**
 * 
 * @export
 * @interface PatchedExperiment
 */
export interface PatchedExperiment {
    /**
     * Canonical URL for this object
     * @type {string}
     * @memberof PatchedExperiment
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedExperiment
     */
    'uuid'?: string;
    /**
     * Title of the experiment
     * @type {string}
     * @memberof PatchedExperiment
     */
    'title'?: string;
    /**
     * Description of the experiment
     * @type {string}
     * @memberof PatchedExperiment
     */
    'description'?: string | null;
    /**
     * Users who created this Experiment
     * @type {Array<string>}
     * @memberof PatchedExperiment
     */
    'authors'?: Array<string>;
    /**
     * Protocol of the experiment
     * @type {{ [key: string]: any; }}
     * @memberof PatchedExperiment
     */
    'protocol'?: { [key: string]: any; } | null;
    /**
     * Protocol file of the experiment
     * @type {string}
     * @memberof PatchedExperiment
     */
    'protocol_file'?: string | null;
    /**
     * Cycler Tests using this Experiment
     * @type {Array<string>}
     * @memberof PatchedExperiment
     */
    'cycler_tests'?: Array<string>;
    /**
     * Team this resource belongs to
     * @type {string}
     * @memberof PatchedExperiment
     */
    'team'?: string;
    /**
     * 
     * @type {CellPermissions}
     * @memberof PatchedExperiment
     */
    'permissions'?: CellPermissions;
}
/**
 * 
 * @export
 * @interface PatchedGroup
 */
export interface PatchedGroup {
    /**
     * 
     * @type {number}
     * @memberof PatchedGroup
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedGroup
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedGroup
     */
    'name'?: string;
    /**
     * Users in the group
     * @type {Array<string>}
     * @memberof PatchedGroup
     */
    'users'?: Array<string>;
    /**
     * 
     * @type {CellPermissions}
     * @memberof PatchedGroup
     */
    'permissions'?: CellPermissions;
    /**
     * Users to add
     * @type {Array<string>}
     * @memberof PatchedGroup
     */
    'add_users'?: Array<string>;
    /**
     * Users to remove
     * @type {Array<string>}
     * @memberof PatchedGroup
     */
    'remove_users'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PatchedHarvester
 */
export interface PatchedHarvester {
    /**
     * Canonical URL for this object
     * @type {string}
     * @memberof PatchedHarvester
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedHarvester
     */
    'uuid'?: string;
    /**
     * Date and time of last Harvester contact
     * @type {string}
     * @memberof PatchedHarvester
     */
    'last_check_in'?: string | null;
    /**
     * Lab this Harvester belongs to
     * @type {string}
     * @memberof PatchedHarvester
     */
    'lab'?: string;
    /**
     * 
     * @type {CellPermissions}
     * @memberof PatchedHarvester
     */
    'permissions'?: CellPermissions;
    /**
     * Human-friendly Harvester identifier
     * @type {string}
     * @memberof PatchedHarvester
     */
    'name'?: string;
    /**
     * Seconds to sleep between Harvester cycles
     * @type {number}
     * @memberof PatchedHarvester
     */
    'sleep_time'?: number;
    /**
     * Environment variables set on this Harvester
     * @type {{ [key: string]: any; }}
     * @memberof PatchedHarvester
     */
    'environment_variables'?: { [key: string]: any; };
    /**
     * Whether the Harvester is active
     * @type {boolean}
     * @memberof PatchedHarvester
     */
    'active'?: boolean;
}
/**
 * 
 * @export
 * @interface PatchedKnoxToken
 */
export interface PatchedKnoxToken {
    /**
     * Canonical URL for this object
     * @type {string}
     * @memberof PatchedKnoxToken
     */
    'url'?: string;
    /**
     * Auto-assigned object identifier
     * @type {number}
     * @memberof PatchedKnoxToken
     */
    'id'?: number;
    /**
     * Convenient human-friendly name
     * @type {string}
     * @memberof PatchedKnoxToken
     */
    'name'?: string;
    /**
     * Date and time of creation
     * @type {string}
     * @memberof PatchedKnoxToken
     */
    'created'?: string;
    /**
     * Date and time token expires (blank = never)
     * @type {string}
     * @memberof PatchedKnoxToken
     */
    'expiry'?: string | null;
}
/**
 * 
 * @export
 * @interface PatchedLab
 */
export interface PatchedLab {
    /**
     * 
     * @type {string}
     * @memberof PatchedLab
     */
    'url'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedLab
     */
    'id'?: number;
    /**
     * Human-friendly Lab identifier
     * @type {string}
     * @memberof PatchedLab
     */
    'name'?: string;
    /**
     * Description of the Lab
     * @type {string}
     * @memberof PatchedLab
     */
    'description'?: string | null;
    /**
     * 
     * @type {LabAdminGroup}
     * @memberof PatchedLab
     */
    'admin_group'?: LabAdminGroup;
    /**
     * Teams in this Lab
     * @type {Array<string>}
     * @memberof PatchedLab
     */
    'teams'?: Array<string>;
    /**
     * 
     * @type {CellPermissions}
     * @memberof PatchedLab
     */
    'permissions'?: CellPermissions;
}
/**
 * 
 * @export
 * @interface PatchedMonitoredPath
 */
export interface PatchedMonitoredPath {
    /**
     * Canonical URL for this object
     * @type {string}
     * @memberof PatchedMonitoredPath
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedMonitoredPath
     */
    'uuid'?: string;
    /**
     * Directory location on Harvester
     * @type {string}
     * @memberof PatchedMonitoredPath
     */
    'path'?: string;
    /**
     *      Python.re regular expression to filter files by,      applied to full file name starting from this Path\'s directory
     * @type {string}
     * @memberof PatchedMonitoredPath
     */
    'regex'?: string | null;
    /**
     * Number of seconds files must remain stable to be processed
     * @type {number}
     * @memberof PatchedMonitoredPath
     */
    'stable_time'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedMonitoredPath
     */
    'active'?: boolean;
    /**
     * Harvester this MonitoredPath belongs to
     * @type {string}
     * @memberof PatchedMonitoredPath
     */
    'harvester'?: string;
    /**
     * Team this resource belongs to
     * @type {string}
     * @memberof PatchedMonitoredPath
     */
    'team'?: string;
    /**
     * 
     * @type {CellPermissions}
     * @memberof PatchedMonitoredPath
     */
    'permissions'?: CellPermissions;
}
/**
 * 
 * @export
 * @interface PatchedObservedFile
 */
export interface PatchedObservedFile {
    /**
     * Canonical URL for this object
     * @type {string}
     * @memberof PatchedObservedFile
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedObservedFile
     */
    'uuid'?: string;
    /**
     * Harvester this File belongs to
     * @type {string}
     * @memberof PatchedObservedFile
     */
    'harvester'?: string;
    /**
     * Absolute file path
     * @type {string}
     * @memberof PatchedObservedFile
     */
    'path'?: string;
    /**
     * File status; autogenerated but can be manually set to RETRY IMPORT
     * @type {string}
     * @memberof PatchedObservedFile
     */
    'state'?: PatchedObservedFileStateEnum;
    /**
     * Parser used by the harvester
     * @type {string}
     * @memberof PatchedObservedFile
     */
    'parser'?: string | null;
    /**
     * Number of rows in the file
     * @type {number}
     * @memberof PatchedObservedFile
     */
    'num_rows'?: number | null;
    /**
     * Number of the first sample in the file
     * @type {number}
     * @memberof PatchedObservedFile
     */
    'first_sample_no'?: number | null;
    /**
     * Number of the last sample in the file
     * @type {number}
     * @memberof PatchedObservedFile
     */
    'last_sample_no'?: number | null;
    /**
     * Extra metadata from the harvester
     * @type {{ [key: string]: any; }}
     * @memberof PatchedObservedFile
     */
    'extra_metadata'?: { [key: string]: any; } | null;
    /**
     * Whether the file has all required columns
     * @type {boolean}
     * @memberof PatchedObservedFile
     */
    'has_required_columns'?: boolean;
    /**
     * Date and time of last Harvester report on file
     * @type {string}
     * @memberof PatchedObservedFile
     */
    'last_observed_time'?: string | null;
    /**
     * Size of the file as last reported by Harvester
     * @type {number}
     * @memberof PatchedObservedFile
     */
    'last_observed_size'?: number;
    /**
     * Errors associated with this File
     * @type {Array<string>}
     * @memberof PatchedObservedFile
     */
    'upload_errors'?: Array<string>;
    /**
     * Errors in uploaded columns
     * @type {Array<any>}
     * @memberof PatchedObservedFile
     */
    'column_errors'?: Array<any>;
    /**
     * Metadata required for harvester program to resume file parsing
     * @type {{ [key: string]: any; }}
     * @memberof PatchedObservedFile
     */
    'upload_info'?: { [key: string]: any; } | null;
    /**
     * Columns extracted from this File
     * @type {Array<string>}
     * @memberof PatchedObservedFile
     */
    'columns'?: Array<string>;
    /**
     * 
     * @type {CellPermissions}
     * @memberof PatchedObservedFile
     */
    'permissions'?: CellPermissions;
    /**
     * Name of the file
     * @type {string}
     * @memberof PatchedObservedFile
     */
    'name'?: string | null;
}

export const PatchedObservedFileStateEnum = {
    RetryImport: 'RETRY IMPORT',
    ImportFailed: 'IMPORT FAILED',
    Unstable: 'UNSTABLE',
    Growing: 'GROWING',
    Stable: 'STABLE',
    Importing: 'IMPORTING',
    Imported: 'IMPORTED'
} as const;

export type PatchedObservedFileStateEnum = typeof PatchedObservedFileStateEnum[keyof typeof PatchedObservedFileStateEnum];

/**
 * A ModelSerializer that maps unrecognised properties in the input to an \'additional_properties\' JSONField, and unpacks the \'additional_properties\' JSONField into the output.  The Meta.model must have an additional_properties JSONField.
 * @export
 * @interface PatchedSchedule
 */
export interface PatchedSchedule {
    /**
     * 
     * @type {string}
     * @memberof PatchedSchedule
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedSchedule
     */
    'uuid'?: string;
    /**
     * Schedule Family this Schedule belongs to
     * @type {string}
     * @memberof PatchedSchedule
     */
    'family'?: string;
    /**
     * File containing the schedule
     * @type {string}
     * @memberof PatchedSchedule
     */
    'schedule_file'?: string | null;
    /**
     * Variables used in the PyBaMM.Experiment representation of the schedule
     * @type {{ [key: string]: any; }}
     * @memberof PatchedSchedule
     */
    'pybamm_schedule_variables'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedSchedule
     */
    'in_use'?: boolean;
    /**
     * Team this resource belongs to
     * @type {string}
     * @memberof PatchedSchedule
     */
    'team'?: string;
    /**
     * Cycler Tests using this Schedule
     * @type {Array<string>}
     * @memberof PatchedSchedule
     */
    'cycler_tests'?: Array<string>;
    /**
     * 
     * @type {CellPermissions}
     * @memberof PatchedSchedule
     */
    'permissions'?: CellPermissions;
}
/**
 * A ModelSerializer that maps unrecognised properties in the input to an \'additional_properties\' JSONField, and unpacks the \'additional_properties\' JSONField into the output.  The Meta.model must have an additional_properties JSONField.
 * @export
 * @interface PatchedScheduleFamily
 */
export interface PatchedScheduleFamily {
    /**
     * 
     * @type {string}
     * @memberof PatchedScheduleFamily
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedScheduleFamily
     */
    'uuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedScheduleFamily
     */
    'identifier'?: string;
    /**
     * Description of the schedule
     * @type {string}
     * @memberof PatchedScheduleFamily
     */
    'description'?: string;
    /**
     * Ambient temperature during the experiment (in degrees Celsius)
     * @type {number}
     * @memberof PatchedScheduleFamily
     */
    'ambient_temperature'?: number | null;
    /**
     * Template for the schedule in PyBaMM format
     * @type {Array<string>}
     * @memberof PatchedScheduleFamily
     */
    'pybamm_template'?: Array<string> | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedScheduleFamily
     */
    'in_use'?: boolean;
    /**
     * Team this resource belongs to
     * @type {string}
     * @memberof PatchedScheduleFamily
     */
    'team'?: string;
    /**
     * Schedules belonging to this Schedule Family
     * @type {Array<string>}
     * @memberof PatchedScheduleFamily
     */
    'schedules'?: Array<string>;
    /**
     * 
     * @type {CellPermissions}
     * @memberof PatchedScheduleFamily
     */
    'permissions'?: CellPermissions;
}
/**
 * 
 * @export
 * @interface PatchedTeam
 */
export interface PatchedTeam {
    /**
     * 
     * @type {string}
     * @memberof PatchedTeam
     */
    'url'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedTeam
     */
    'id'?: number;
    /**
     * 
     * @type {PatchedTeamMemberGroup}
     * @memberof PatchedTeam
     */
    'member_group'?: PatchedTeamMemberGroup;
    /**
     * 
     * @type {PatchedTeamAdminGroup}
     * @memberof PatchedTeam
     */
    'admin_group'?: PatchedTeamAdminGroup;
    /**
     * 
     * @type {Array<string>}
     * @memberof PatchedTeam
     */
    'monitored_paths'?: Array<string>;
    /**
     * Cell Families belonging to this Team
     * @type {Array<string>}
     * @memberof PatchedTeam
     */
    'cellfamily_resources'?: Array<string>;
    /**
     * Cells belonging to this Team
     * @type {Array<string>}
     * @memberof PatchedTeam
     */
    'cell_resources'?: Array<string>;
    /**
     * Equipment Families belonging to this Team
     * @type {Array<string>}
     * @memberof PatchedTeam
     */
    'equipmentfamily_resources'?: Array<string>;
    /**
     * Equipment belonging to this Team
     * @type {Array<string>}
     * @memberof PatchedTeam
     */
    'equipment_resources'?: Array<string>;
    /**
     * Schedule Families belonging to this Team
     * @type {Array<string>}
     * @memberof PatchedTeam
     */
    'schedulefamily_resources'?: Array<string>;
    /**
     * Schedules belonging to this Team
     * @type {Array<string>}
     * @memberof PatchedTeam
     */
    'schedule_resources'?: Array<string>;
    /**
     * Cycler Tests belonging to this Team
     * @type {Array<string>}
     * @memberof PatchedTeam
     */
    'cyclertest_resources'?: Array<string>;
    /**
     * Experiments belonging to this Team
     * @type {Array<string>}
     * @memberof PatchedTeam
     */
    'experiment_resources'?: Array<string>;
    /**
     * 
     * @type {CellPermissions}
     * @memberof PatchedTeam
     */
    'permissions'?: CellPermissions;
    /**
     * Human-friendly Team identifier
     * @type {string}
     * @memberof PatchedTeam
     */
    'name'?: string;
    /**
     * Description of the Team
     * @type {string}
     * @memberof PatchedTeam
     */
    'description'?: string | null;
    /**
     * Lab this Team belongs to
     * @type {string}
     * @memberof PatchedTeam
     */
    'lab'?: string;
}
/**
 * Administrators of this Team
 * @export
 * @interface PatchedTeamAdminGroup
 */
export interface PatchedTeamAdminGroup {
    /**
     * 
     * @type {number}
     * @memberof PatchedTeamAdminGroup
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof PatchedTeamAdminGroup
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof PatchedTeamAdminGroup
     */
    'name': string;
    /**
     * Users in the group
     * @type {Array<string>}
     * @memberof PatchedTeamAdminGroup
     */
    'users': Array<string>;
    /**
     * 
     * @type {CellPermissions}
     * @memberof PatchedTeamAdminGroup
     */
    'permissions': CellPermissions;
    /**
     * Users to add
     * @type {Array<string>}
     * @memberof PatchedTeamAdminGroup
     */
    'add_users'?: Array<string>;
    /**
     * Users to remove
     * @type {Array<string>}
     * @memberof PatchedTeamAdminGroup
     */
    'remove_users'?: Array<string>;
}
/**
 * Members of this Team
 * @export
 * @interface PatchedTeamMemberGroup
 */
export interface PatchedTeamMemberGroup {
    /**
     * 
     * @type {number}
     * @memberof PatchedTeamMemberGroup
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof PatchedTeamMemberGroup
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof PatchedTeamMemberGroup
     */
    'name': string;
    /**
     * Users in the group
     * @type {Array<string>}
     * @memberof PatchedTeamMemberGroup
     */
    'users': Array<string>;
    /**
     * 
     * @type {CellPermissions}
     * @memberof PatchedTeamMemberGroup
     */
    'permissions': CellPermissions;
    /**
     * Users to add
     * @type {Array<string>}
     * @memberof PatchedTeamMemberGroup
     */
    'add_users'?: Array<string>;
    /**
     * Users to remove
     * @type {Array<string>}
     * @memberof PatchedTeamMemberGroup
     */
    'remove_users'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PatchedUserUpdate
 */
export interface PatchedUserUpdate {
    /**
     * Your updated email
     * @type {string}
     * @memberof PatchedUserUpdate
     */
    'email'?: string;
    /**
     * Your new password
     * @type {string}
     * @memberof PatchedUserUpdate
     */
    'password'?: string;
    /**
     * Your current password
     * @type {string}
     * @memberof PatchedUserUpdate
     */
    'currentPassword'?: string;
}
/**
 * 
 * @export
 * @interface PatchedValidationSchema
 */
export interface PatchedValidationSchema {
    /**
     * 
     * @type {string}
     * @memberof PatchedValidationSchema
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedValidationSchema
     */
    'uuid'?: string;
    /**
     * Team this resource belongs to
     * @type {string}
     * @memberof PatchedValidationSchema
     */
    'team'?: string;
    /**
     * Human-friendly identifier
     * @type {string}
     * @memberof PatchedValidationSchema
     */
    'name'?: string;
    /**
     * JSON Schema
     * @type {{ [key: string]: any; }}
     * @memberof PatchedValidationSchema
     */
    'schema'?: { [key: string]: any; };
    /**
     * 
     * @type {CellPermissions}
     * @memberof PatchedValidationSchema
     */
    'permissions'?: CellPermissions;
}
/**
 * A ModelSerializer that maps unrecognised properties in the input to an \'additional_properties\' JSONField, and unpacks the \'additional_properties\' JSONField into the output.  The Meta.model must have an additional_properties JSONField.
 * @export
 * @interface Schedule
 */
export interface Schedule {
    /**
     * 
     * @type {string}
     * @memberof Schedule
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof Schedule
     */
    'uuid': string;
    /**
     * Schedule Family this Schedule belongs to
     * @type {string}
     * @memberof Schedule
     */
    'family': string;
    /**
     * File containing the schedule
     * @type {string}
     * @memberof Schedule
     */
    'schedule_file'?: string | null;
    /**
     * Variables used in the PyBaMM.Experiment representation of the schedule
     * @type {{ [key: string]: any; }}
     * @memberof Schedule
     */
    'pybamm_schedule_variables'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {boolean}
     * @memberof Schedule
     */
    'in_use': boolean;
    /**
     * Team this resource belongs to
     * @type {string}
     * @memberof Schedule
     */
    'team': string;
    /**
     * Cycler Tests using this Schedule
     * @type {Array<string>}
     * @memberof Schedule
     */
    'cycler_tests': Array<string>;
    /**
     * 
     * @type {CellPermissions}
     * @memberof Schedule
     */
    'permissions': CellPermissions;
}
/**
 * A ModelSerializer that maps unrecognised properties in the input to an \'additional_properties\' JSONField, and unpacks the \'additional_properties\' JSONField into the output.  The Meta.model must have an additional_properties JSONField.
 * @export
 * @interface ScheduleFamily
 */
export interface ScheduleFamily {
    /**
     * 
     * @type {string}
     * @memberof ScheduleFamily
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof ScheduleFamily
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof ScheduleFamily
     */
    'identifier': string;
    /**
     * Description of the schedule
     * @type {string}
     * @memberof ScheduleFamily
     */
    'description': string;
    /**
     * Ambient temperature during the experiment (in degrees Celsius)
     * @type {number}
     * @memberof ScheduleFamily
     */
    'ambient_temperature'?: number | null;
    /**
     * Template for the schedule in PyBaMM format
     * @type {Array<string>}
     * @memberof ScheduleFamily
     */
    'pybamm_template'?: Array<string> | null;
    /**
     * 
     * @type {boolean}
     * @memberof ScheduleFamily
     */
    'in_use': boolean;
    /**
     * Team this resource belongs to
     * @type {string}
     * @memberof ScheduleFamily
     */
    'team': string;
    /**
     * Schedules belonging to this Schedule Family
     * @type {Array<string>}
     * @memberof ScheduleFamily
     */
    'schedules': Array<string>;
    /**
     * 
     * @type {CellPermissions}
     * @memberof ScheduleFamily
     */
    'permissions': CellPermissions;
}
/**
 * 
 * @export
 * @interface Team
 */
export interface Team {
    /**
     * 
     * @type {string}
     * @memberof Team
     */
    'url': string;
    /**
     * 
     * @type {number}
     * @memberof Team
     */
    'id': number;
    /**
     * 
     * @type {PatchedTeamMemberGroup}
     * @memberof Team
     */
    'member_group': PatchedTeamMemberGroup;
    /**
     * 
     * @type {PatchedTeamAdminGroup}
     * @memberof Team
     */
    'admin_group': PatchedTeamAdminGroup;
    /**
     * 
     * @type {Array<string>}
     * @memberof Team
     */
    'monitored_paths': Array<string>;
    /**
     * Cell Families belonging to this Team
     * @type {Array<string>}
     * @memberof Team
     */
    'cellfamily_resources': Array<string>;
    /**
     * Cells belonging to this Team
     * @type {Array<string>}
     * @memberof Team
     */
    'cell_resources': Array<string>;
    /**
     * Equipment Families belonging to this Team
     * @type {Array<string>}
     * @memberof Team
     */
    'equipmentfamily_resources': Array<string>;
    /**
     * Equipment belonging to this Team
     * @type {Array<string>}
     * @memberof Team
     */
    'equipment_resources': Array<string>;
    /**
     * Schedule Families belonging to this Team
     * @type {Array<string>}
     * @memberof Team
     */
    'schedulefamily_resources': Array<string>;
    /**
     * Schedules belonging to this Team
     * @type {Array<string>}
     * @memberof Team
     */
    'schedule_resources': Array<string>;
    /**
     * Cycler Tests belonging to this Team
     * @type {Array<string>}
     * @memberof Team
     */
    'cyclertest_resources': Array<string>;
    /**
     * Experiments belonging to this Team
     * @type {Array<string>}
     * @memberof Team
     */
    'experiment_resources': Array<string>;
    /**
     * 
     * @type {CellPermissions}
     * @memberof Team
     */
    'permissions': CellPermissions;
    /**
     * Human-friendly Team identifier
     * @type {string}
     * @memberof Team
     */
    'name': string;
    /**
     * Description of the Team
     * @type {string}
     * @memberof Team
     */
    'description'?: string | null;
    /**
     * Lab this Team belongs to
     * @type {string}
     * @memberof Team
     */
    'lab': string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.
     * @type {string}
     * @memberof User
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'last_name'?: string;
    /**
     * Canonical URL for this object
     * @type {string}
     * @memberof User
     */
    'url': string;
    /**
     * Auto-assigned object identifier
     * @type {number}
     * @memberof User
     */
    'id': number;
    /**
     * Designates whether the user can log into this admin site.
     * @type {boolean}
     * @memberof User
     */
    'is_staff': boolean;
    /**
     * Designates that this user has all permissions without explicitly assigning them.
     * @type {boolean}
     * @memberof User
     */
    'is_superuser': boolean;
    /**
     * Groups this user belongs to
     * @type {Array<string>}
     * @memberof User
     */
    'groups': Array<string>;
    /**
     * 
     * @type {CellPermissions}
     * @memberof User
     */
    'permissions': CellPermissions;
    /**
     * Password (8 characters minimum)
     * @type {string}
     * @memberof User
     */
    'password': string;
    /**
     * Current password
     * @type {string}
     * @memberof User
     */
    'current_password'?: string;
}
/**
 * 
 * @export
 * @interface ValidationSchema
 */
export interface ValidationSchema {
    /**
     * 
     * @type {string}
     * @memberof ValidationSchema
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationSchema
     */
    'uuid': string;
    /**
     * Team this resource belongs to
     * @type {string}
     * @memberof ValidationSchema
     */
    'team': string;
    /**
     * Human-friendly identifier
     * @type {string}
     * @memberof ValidationSchema
     */
    'name': string;
    /**
     * JSON Schema
     * @type {{ [key: string]: any; }}
     * @memberof ValidationSchema
     */
    'schema': { [key: string]: any; };
    /**
     * 
     * @type {CellPermissions}
     * @memberof ValidationSchema
     */
    'permissions': CellPermissions;
}
/**
 * 
 * @export
 * @interface ValidationSchemaRootKeys
 */
export interface ValidationSchemaRootKeys {
    /**
     * Name of the root key
     * @type {string}
     * @memberof ValidationSchemaRootKeys
     */
    'key': string;
    /**
     * URL of the objects the key describes
     * @type {string}
     * @memberof ValidationSchemaRootKeys
     */
    'describes': string;
}

/**
 * CellChemistriesApi - axios parameter creator
 * @export
 */
export const CellChemistriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cell Chemistries are used to describe the chemistry of cell used in an experiment. Examples are \"NMC\", \"LFP\".
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cellChemistriesList: async (limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cell_chemistries/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CellChemistriesApi - functional programming interface
 * @export
 */
export const CellChemistriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CellChemistriesApiAxiosParamCreator(configuration)
    return {
        /**
         * Cell Chemistries are used to describe the chemistry of cell used in an experiment. Examples are \"NMC\", \"LFP\".
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cellChemistriesList(limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CellChemistriesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cellChemistriesList(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CellChemistriesApi - factory interface
 * @export
 */
export const CellChemistriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CellChemistriesApiFp(configuration)
    return {
        /**
         * Cell Chemistries are used to describe the chemistry of cell used in an experiment. Examples are \"NMC\", \"LFP\".
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cellChemistriesList(limit?: number, offset?: number, options?: any): AxiosPromise<CellChemistriesList200Response> {
            return localVarFp.cellChemistriesList(limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CellChemistriesApi - object-oriented interface
 * @export
 * @class CellChemistriesApi
 * @extends {BaseAPI}
 */
export class CellChemistriesApi extends BaseAPI {
    /**
     * Cell Chemistries are used to describe the chemistry of cell used in an experiment. Examples are \"NMC\", \"LFP\".
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CellChemistriesApi
     */
    public cellChemistriesList(limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return CellChemistriesApiFp(this.configuration).cellChemistriesList(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CellFamiliesApi - axios parameter creator
 * @export
 */
export const CellFamiliesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Cell Families group together the general properties of a type of Cell. Each Cell is associated with a Cell Family.         
         * @summary Create a Cell Family
         * @param {CellFamily} cellFamily 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cellFamiliesCreate: async (cellFamily: CellFamily, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cellFamily' is not null or undefined
            assertParamExists('cellFamiliesCreate', 'cellFamily', cellFamily)
            const localVarPath = `/cell_families/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cellFamily, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Cell Families that do not have any Cells associated with them may be deleted. Cell Families that _do_ have Cells associated with them are locked, to prevent accidental updating.         
         * @summary Delete a Cell Family
         * @param {string} uuid A UUID string identifying this cell family.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cellFamiliesDestroy: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('cellFamiliesDestroy', 'uuid', uuid)
            const localVarPath = `/cell_families/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Cell Families group together the general properties of a type of Cell. Each Cell is associated with a Cell Family.  Searchable fields: - name - manufacturer - form_factor         
         * @summary View Cell Families
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cellFamiliesList: async (limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cell_families/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Cell Families that do not have any Cells associated with them may be edited. Cell Families that _do_ have Cells associated with them are locked, to prevent accidental updating.         
         * @summary Update a Cell Family
         * @param {string} uuid A UUID string identifying this cell family.
         * @param {PatchedCellFamily} [patchedCellFamily] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cellFamiliesPartialUpdate: async (uuid: string, patchedCellFamily?: PatchedCellFamily, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('cellFamiliesPartialUpdate', 'uuid', uuid)
            const localVarPath = `/cell_families/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedCellFamily, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Cell Families group together the general properties of a type of Cell. Each Cell is associated with a Cell Family.         
         * @summary View a Cell Family
         * @param {string} uuid A UUID string identifying this cell family.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cellFamiliesRetrieve: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('cellFamiliesRetrieve', 'uuid', uuid)
            const localVarPath = `/cell_families/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * CellFamilies describe types of Cell.
         * @param {string} uuid A UUID string identifying this cell family.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cellFamiliesWithValidationRetrieve: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('cellFamiliesWithValidationRetrieve', 'uuid', uuid)
            const localVarPath = `/cell_families/{uuid}/with_validation/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CellFamiliesApi - functional programming interface
 * @export
 */
export const CellFamiliesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CellFamiliesApiAxiosParamCreator(configuration)
    return {
        /**
         *  Cell Families group together the general properties of a type of Cell. Each Cell is associated with a Cell Family.         
         * @summary Create a Cell Family
         * @param {CellFamily} cellFamily 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cellFamiliesCreate(cellFamily: CellFamily, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CellFamily>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cellFamiliesCreate(cellFamily, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Cell Families that do not have any Cells associated with them may be deleted. Cell Families that _do_ have Cells associated with them are locked, to prevent accidental updating.         
         * @summary Delete a Cell Family
         * @param {string} uuid A UUID string identifying this cell family.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cellFamiliesDestroy(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cellFamiliesDestroy(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Cell Families group together the general properties of a type of Cell. Each Cell is associated with a Cell Family.  Searchable fields: - name - manufacturer - form_factor         
         * @summary View Cell Families
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cellFamiliesList(limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedCellFamilyList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cellFamiliesList(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Cell Families that do not have any Cells associated with them may be edited. Cell Families that _do_ have Cells associated with them are locked, to prevent accidental updating.         
         * @summary Update a Cell Family
         * @param {string} uuid A UUID string identifying this cell family.
         * @param {PatchedCellFamily} [patchedCellFamily] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cellFamiliesPartialUpdate(uuid: string, patchedCellFamily?: PatchedCellFamily, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CellFamily>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cellFamiliesPartialUpdate(uuid, patchedCellFamily, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Cell Families group together the general properties of a type of Cell. Each Cell is associated with a Cell Family.         
         * @summary View a Cell Family
         * @param {string} uuid A UUID string identifying this cell family.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cellFamiliesRetrieve(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CellFamily>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cellFamiliesRetrieve(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * CellFamilies describe types of Cell.
         * @param {string} uuid A UUID string identifying this cell family.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cellFamiliesWithValidationRetrieve(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CellFamily>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cellFamiliesWithValidationRetrieve(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CellFamiliesApi - factory interface
 * @export
 */
export const CellFamiliesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CellFamiliesApiFp(configuration)
    return {
        /**
         *  Cell Families group together the general properties of a type of Cell. Each Cell is associated with a Cell Family.         
         * @summary Create a Cell Family
         * @param {CellFamily} cellFamily 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cellFamiliesCreate(cellFamily: CellFamily, options?: any): AxiosPromise<CellFamily> {
            return localVarFp.cellFamiliesCreate(cellFamily, options).then((request) => request(axios, basePath));
        },
        /**
         *  Cell Families that do not have any Cells associated with them may be deleted. Cell Families that _do_ have Cells associated with them are locked, to prevent accidental updating.         
         * @summary Delete a Cell Family
         * @param {string} uuid A UUID string identifying this cell family.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cellFamiliesDestroy(uuid: string, options?: any): AxiosPromise<void> {
            return localVarFp.cellFamiliesDestroy(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         *  Cell Families group together the general properties of a type of Cell. Each Cell is associated with a Cell Family.  Searchable fields: - name - manufacturer - form_factor         
         * @summary View Cell Families
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cellFamiliesList(limit?: number, offset?: number, options?: any): AxiosPromise<PaginatedCellFamilyList> {
            return localVarFp.cellFamiliesList(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         *  Cell Families that do not have any Cells associated with them may be edited. Cell Families that _do_ have Cells associated with them are locked, to prevent accidental updating.         
         * @summary Update a Cell Family
         * @param {string} uuid A UUID string identifying this cell family.
         * @param {PatchedCellFamily} [patchedCellFamily] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cellFamiliesPartialUpdate(uuid: string, patchedCellFamily?: PatchedCellFamily, options?: any): AxiosPromise<CellFamily> {
            return localVarFp.cellFamiliesPartialUpdate(uuid, patchedCellFamily, options).then((request) => request(axios, basePath));
        },
        /**
         *  Cell Families group together the general properties of a type of Cell. Each Cell is associated with a Cell Family.         
         * @summary View a Cell Family
         * @param {string} uuid A UUID string identifying this cell family.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cellFamiliesRetrieve(uuid: string, options?: any): AxiosPromise<CellFamily> {
            return localVarFp.cellFamiliesRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * CellFamilies describe types of Cell.
         * @param {string} uuid A UUID string identifying this cell family.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cellFamiliesWithValidationRetrieve(uuid: string, options?: any): AxiosPromise<CellFamily> {
            return localVarFp.cellFamiliesWithValidationRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CellFamiliesApi - object-oriented interface
 * @export
 * @class CellFamiliesApi
 * @extends {BaseAPI}
 */
export class CellFamiliesApi extends BaseAPI {
    /**
     *  Cell Families group together the general properties of a type of Cell. Each Cell is associated with a Cell Family.         
     * @summary Create a Cell Family
     * @param {CellFamily} cellFamily 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CellFamiliesApi
     */
    public cellFamiliesCreate(cellFamily: CellFamily, options?: AxiosRequestConfig) {
        return CellFamiliesApiFp(this.configuration).cellFamiliesCreate(cellFamily, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Cell Families that do not have any Cells associated with them may be deleted. Cell Families that _do_ have Cells associated with them are locked, to prevent accidental updating.         
     * @summary Delete a Cell Family
     * @param {string} uuid A UUID string identifying this cell family.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CellFamiliesApi
     */
    public cellFamiliesDestroy(uuid: string, options?: AxiosRequestConfig) {
        return CellFamiliesApiFp(this.configuration).cellFamiliesDestroy(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Cell Families group together the general properties of a type of Cell. Each Cell is associated with a Cell Family.  Searchable fields: - name - manufacturer - form_factor         
     * @summary View Cell Families
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CellFamiliesApi
     */
    public cellFamiliesList(limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return CellFamiliesApiFp(this.configuration).cellFamiliesList(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Cell Families that do not have any Cells associated with them may be edited. Cell Families that _do_ have Cells associated with them are locked, to prevent accidental updating.         
     * @summary Update a Cell Family
     * @param {string} uuid A UUID string identifying this cell family.
     * @param {PatchedCellFamily} [patchedCellFamily] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CellFamiliesApi
     */
    public cellFamiliesPartialUpdate(uuid: string, patchedCellFamily?: PatchedCellFamily, options?: AxiosRequestConfig) {
        return CellFamiliesApiFp(this.configuration).cellFamiliesPartialUpdate(uuid, patchedCellFamily, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Cell Families group together the general properties of a type of Cell. Each Cell is associated with a Cell Family.         
     * @summary View a Cell Family
     * @param {string} uuid A UUID string identifying this cell family.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CellFamiliesApi
     */
    public cellFamiliesRetrieve(uuid: string, options?: AxiosRequestConfig) {
        return CellFamiliesApiFp(this.configuration).cellFamiliesRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * CellFamilies describe types of Cell.
     * @param {string} uuid A UUID string identifying this cell family.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CellFamiliesApi
     */
    public cellFamiliesWithValidationRetrieve(uuid: string, options?: AxiosRequestConfig) {
        return CellFamiliesApiFp(this.configuration).cellFamiliesWithValidationRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CellFormFactorsApi - axios parameter creator
 * @export
 */
export const CellFormFactorsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cell Form Factors are used to describe the form factor of cell used in an experiment. Examples are \"Pouch\", \"Cylindrical\".
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cellFormFactorsList: async (limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cell_form_factors/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CellFormFactorsApi - functional programming interface
 * @export
 */
export const CellFormFactorsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CellFormFactorsApiAxiosParamCreator(configuration)
    return {
        /**
         * Cell Form Factors are used to describe the form factor of cell used in an experiment. Examples are \"Pouch\", \"Cylindrical\".
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cellFormFactorsList(limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CellChemistriesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cellFormFactorsList(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CellFormFactorsApi - factory interface
 * @export
 */
export const CellFormFactorsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CellFormFactorsApiFp(configuration)
    return {
        /**
         * Cell Form Factors are used to describe the form factor of cell used in an experiment. Examples are \"Pouch\", \"Cylindrical\".
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cellFormFactorsList(limit?: number, offset?: number, options?: any): AxiosPromise<CellChemistriesList200Response> {
            return localVarFp.cellFormFactorsList(limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CellFormFactorsApi - object-oriented interface
 * @export
 * @class CellFormFactorsApi
 * @extends {BaseAPI}
 */
export class CellFormFactorsApi extends BaseAPI {
    /**
     * Cell Form Factors are used to describe the form factor of cell used in an experiment. Examples are \"Pouch\", \"Cylindrical\".
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CellFormFactorsApi
     */
    public cellFormFactorsList(limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return CellFormFactorsApiFp(this.configuration).cellFormFactorsList(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CellManufacturersApi - axios parameter creator
 * @export
 */
export const CellManufacturersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cell Manufacturers are used to describe the manufacturer of cell used in an experiment. Examples are \"Sony\", \"LG\".
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cellManufacturersList: async (limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cell_manufacturers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CellManufacturersApi - functional programming interface
 * @export
 */
export const CellManufacturersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CellManufacturersApiAxiosParamCreator(configuration)
    return {
        /**
         * Cell Manufacturers are used to describe the manufacturer of cell used in an experiment. Examples are \"Sony\", \"LG\".
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cellManufacturersList(limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CellChemistriesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cellManufacturersList(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CellManufacturersApi - factory interface
 * @export
 */
export const CellManufacturersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CellManufacturersApiFp(configuration)
    return {
        /**
         * Cell Manufacturers are used to describe the manufacturer of cell used in an experiment. Examples are \"Sony\", \"LG\".
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cellManufacturersList(limit?: number, offset?: number, options?: any): AxiosPromise<CellChemistriesList200Response> {
            return localVarFp.cellManufacturersList(limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CellManufacturersApi - object-oriented interface
 * @export
 * @class CellManufacturersApi
 * @extends {BaseAPI}
 */
export class CellManufacturersApi extends BaseAPI {
    /**
     * Cell Manufacturers are used to describe the manufacturer of cell used in an experiment. Examples are \"Sony\", \"LG\".
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CellManufacturersApi
     */
    public cellManufacturersList(limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return CellManufacturersApiFp(this.configuration).cellManufacturersList(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CellModelsApi - axios parameter creator
 * @export
 */
export const CellModelsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cell Models are used to describe the model of cell used in an experiment. Examples are \"VTC6\", \"HG2\".
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cellModelsList: async (limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cell_models/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CellModelsApi - functional programming interface
 * @export
 */
export const CellModelsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CellModelsApiAxiosParamCreator(configuration)
    return {
        /**
         * Cell Models are used to describe the model of cell used in an experiment. Examples are \"VTC6\", \"HG2\".
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cellModelsList(limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CellChemistriesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cellModelsList(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CellModelsApi - factory interface
 * @export
 */
export const CellModelsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CellModelsApiFp(configuration)
    return {
        /**
         * Cell Models are used to describe the model of cell used in an experiment. Examples are \"VTC6\", \"HG2\".
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cellModelsList(limit?: number, offset?: number, options?: any): AxiosPromise<CellChemistriesList200Response> {
            return localVarFp.cellModelsList(limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CellModelsApi - object-oriented interface
 * @export
 * @class CellModelsApi
 * @extends {BaseAPI}
 */
export class CellModelsApi extends BaseAPI {
    /**
     * Cell Models are used to describe the model of cell used in an experiment. Examples are \"VTC6\", \"HG2\".
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CellModelsApi
     */
    public cellModelsList(limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return CellModelsApiFp(this.configuration).cellModelsList(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CellsApi - axios parameter creator
 * @export
 */
export const CellsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Create an instance of a Cell by declaring its unique identifier and associated Cell Family.         
         * @summary Create a Cell
         * @param {Cell} cell 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cellsCreate: async (cell: Cell, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cell' is not null or undefined
            assertParamExists('cellsCreate', 'cell', cell)
            const localVarPath = `/cells/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cell, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Cells that are not used in Cycler Tests may be deleted. Cells that _are_ used in a Cycler Tests are locked to prevent accidental updating.         
         * @summary Delete a Cell
         * @param {string} uuid A UUID string identifying this cell.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cellsDestroy: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('cellsDestroy', 'uuid', uuid)
            const localVarPath = `/cells/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Cells are specific cells which generate data stored in Datasets/observed Files.  Searchable fields: - identifier         
         * @summary View Cells
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cellsList: async (limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cells/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Cells that are not used in Cycler Tests may be edited. Cells that _are_ used in a Cycler Tests are locked to prevent accidental updating.         
         * @summary Update a Cell
         * @param {string} uuid A UUID string identifying this cell.
         * @param {PatchedCell} [patchedCell] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cellsPartialUpdate: async (uuid: string, patchedCell?: PatchedCell, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('cellsPartialUpdate', 'uuid', uuid)
            const localVarPath = `/cells/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedCell, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Dump the Cell in RDF (JSON-LD) format.         
         * @summary View a Cell in RDF (JSON-LD)
         * @param {string} uuid A UUID string identifying this cell.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cellsRdfRetrieve: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('cellsRdfRetrieve', 'uuid', uuid)
            const localVarPath = `/cells/{uuid}/rdf/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Cells are specific cells which generate data stored in Datasets/observed Files.         
         * @summary View a Cell
         * @param {string} uuid A UUID string identifying this cell.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cellsRetrieve: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('cellsRetrieve', 'uuid', uuid)
            const localVarPath = `/cells/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cells are specific cells which have generated data stored in Datasets/ObservedFiles.
         * @param {string} uuid A UUID string identifying this cell.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cellsWithValidationRetrieve: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('cellsWithValidationRetrieve', 'uuid', uuid)
            const localVarPath = `/cells/{uuid}/with_validation/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CellsApi - functional programming interface
 * @export
 */
export const CellsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CellsApiAxiosParamCreator(configuration)
    return {
        /**
         *  Create an instance of a Cell by declaring its unique identifier and associated Cell Family.         
         * @summary Create a Cell
         * @param {Cell} cell 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cellsCreate(cell: Cell, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cell>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cellsCreate(cell, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Cells that are not used in Cycler Tests may be deleted. Cells that _are_ used in a Cycler Tests are locked to prevent accidental updating.         
         * @summary Delete a Cell
         * @param {string} uuid A UUID string identifying this cell.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cellsDestroy(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cellsDestroy(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Cells are specific cells which generate data stored in Datasets/observed Files.  Searchable fields: - identifier         
         * @summary View Cells
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cellsList(limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedCellList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cellsList(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Cells that are not used in Cycler Tests may be edited. Cells that _are_ used in a Cycler Tests are locked to prevent accidental updating.         
         * @summary Update a Cell
         * @param {string} uuid A UUID string identifying this cell.
         * @param {PatchedCell} [patchedCell] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cellsPartialUpdate(uuid: string, patchedCell?: PatchedCell, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cell>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cellsPartialUpdate(uuid, patchedCell, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Dump the Cell in RDF (JSON-LD) format.         
         * @summary View a Cell in RDF (JSON-LD)
         * @param {string} uuid A UUID string identifying this cell.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cellsRdfRetrieve(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cell>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cellsRdfRetrieve(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Cells are specific cells which generate data stored in Datasets/observed Files.         
         * @summary View a Cell
         * @param {string} uuid A UUID string identifying this cell.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cellsRetrieve(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cell>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cellsRetrieve(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Cells are specific cells which have generated data stored in Datasets/ObservedFiles.
         * @param {string} uuid A UUID string identifying this cell.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cellsWithValidationRetrieve(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cell>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cellsWithValidationRetrieve(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CellsApi - factory interface
 * @export
 */
export const CellsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CellsApiFp(configuration)
    return {
        /**
         *  Create an instance of a Cell by declaring its unique identifier and associated Cell Family.         
         * @summary Create a Cell
         * @param {Cell} cell 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cellsCreate(cell: Cell, options?: any): AxiosPromise<Cell> {
            return localVarFp.cellsCreate(cell, options).then((request) => request(axios, basePath));
        },
        /**
         *  Cells that are not used in Cycler Tests may be deleted. Cells that _are_ used in a Cycler Tests are locked to prevent accidental updating.         
         * @summary Delete a Cell
         * @param {string} uuid A UUID string identifying this cell.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cellsDestroy(uuid: string, options?: any): AxiosPromise<void> {
            return localVarFp.cellsDestroy(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         *  Cells are specific cells which generate data stored in Datasets/observed Files.  Searchable fields: - identifier         
         * @summary View Cells
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cellsList(limit?: number, offset?: number, options?: any): AxiosPromise<PaginatedCellList> {
            return localVarFp.cellsList(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         *  Cells that are not used in Cycler Tests may be edited. Cells that _are_ used in a Cycler Tests are locked to prevent accidental updating.         
         * @summary Update a Cell
         * @param {string} uuid A UUID string identifying this cell.
         * @param {PatchedCell} [patchedCell] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cellsPartialUpdate(uuid: string, patchedCell?: PatchedCell, options?: any): AxiosPromise<Cell> {
            return localVarFp.cellsPartialUpdate(uuid, patchedCell, options).then((request) => request(axios, basePath));
        },
        /**
         *  Dump the Cell in RDF (JSON-LD) format.         
         * @summary View a Cell in RDF (JSON-LD)
         * @param {string} uuid A UUID string identifying this cell.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cellsRdfRetrieve(uuid: string, options?: any): AxiosPromise<Cell> {
            return localVarFp.cellsRdfRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         *  Cells are specific cells which generate data stored in Datasets/observed Files.         
         * @summary View a Cell
         * @param {string} uuid A UUID string identifying this cell.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cellsRetrieve(uuid: string, options?: any): AxiosPromise<Cell> {
            return localVarFp.cellsRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Cells are specific cells which have generated data stored in Datasets/ObservedFiles.
         * @param {string} uuid A UUID string identifying this cell.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cellsWithValidationRetrieve(uuid: string, options?: any): AxiosPromise<Cell> {
            return localVarFp.cellsWithValidationRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CellsApi - object-oriented interface
 * @export
 * @class CellsApi
 * @extends {BaseAPI}
 */
export class CellsApi extends BaseAPI {
    /**
     *  Create an instance of a Cell by declaring its unique identifier and associated Cell Family.         
     * @summary Create a Cell
     * @param {Cell} cell 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CellsApi
     */
    public cellsCreate(cell: Cell, options?: AxiosRequestConfig) {
        return CellsApiFp(this.configuration).cellsCreate(cell, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Cells that are not used in Cycler Tests may be deleted. Cells that _are_ used in a Cycler Tests are locked to prevent accidental updating.         
     * @summary Delete a Cell
     * @param {string} uuid A UUID string identifying this cell.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CellsApi
     */
    public cellsDestroy(uuid: string, options?: AxiosRequestConfig) {
        return CellsApiFp(this.configuration).cellsDestroy(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Cells are specific cells which generate data stored in Datasets/observed Files.  Searchable fields: - identifier         
     * @summary View Cells
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CellsApi
     */
    public cellsList(limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return CellsApiFp(this.configuration).cellsList(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Cells that are not used in Cycler Tests may be edited. Cells that _are_ used in a Cycler Tests are locked to prevent accidental updating.         
     * @summary Update a Cell
     * @param {string} uuid A UUID string identifying this cell.
     * @param {PatchedCell} [patchedCell] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CellsApi
     */
    public cellsPartialUpdate(uuid: string, patchedCell?: PatchedCell, options?: AxiosRequestConfig) {
        return CellsApiFp(this.configuration).cellsPartialUpdate(uuid, patchedCell, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Dump the Cell in RDF (JSON-LD) format.         
     * @summary View a Cell in RDF (JSON-LD)
     * @param {string} uuid A UUID string identifying this cell.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CellsApi
     */
    public cellsRdfRetrieve(uuid: string, options?: AxiosRequestConfig) {
        return CellsApiFp(this.configuration).cellsRdfRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Cells are specific cells which generate data stored in Datasets/observed Files.         
     * @summary View a Cell
     * @param {string} uuid A UUID string identifying this cell.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CellsApi
     */
    public cellsRetrieve(uuid: string, options?: AxiosRequestConfig) {
        return CellsApiFp(this.configuration).cellsRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cells are specific cells which have generated data stored in Datasets/ObservedFiles.
     * @param {string} uuid A UUID string identifying this cell.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CellsApi
     */
    public cellsWithValidationRetrieve(uuid: string, options?: AxiosRequestConfig) {
        return CellsApiFp(this.configuration).cellsWithValidationRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ColumnTypesApi - axios parameter creator
 * @export
 */
export const ColumnTypesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Column Types are generic Column templates. They hold the metadata for a Column, while the individual Column instances link Column Types to the TimeseriesData they contain.  Some Column Types are innately recognised by Galv and its harvester parsers, while others can be defined by the parsers during data processing.  Searchable fields: - name - description         
         * @summary View Column Types
         * @param {boolean} [isDefault] 
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [unitName] 
         * @param {string} [unitSymbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        columnTypesList: async (isDefault?: boolean, limit?: number, name?: string, offset?: number, unitName?: string, unitSymbol?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/column_types/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (isDefault !== undefined) {
                localVarQueryParameter['is_default'] = isDefault;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (unitName !== undefined) {
                localVarQueryParameter['unit__name'] = unitName;
            }

            if (unitSymbol !== undefined) {
                localVarQueryParameter['unit__symbol'] = unitSymbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Column Types are generic Column templates. They hold the metadata for a Column, while the individual Column instances link Column Types to the TimeseriesData they contain.  Some Column Types are innately recognised by Galv and its harvester parsers, while others can be defined by the parsers during data processing.  Searchable fields: - name - description         
         * @summary View a Column Type
         * @param {number} id A unique integer value identifying this data column type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        columnTypesRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('columnTypesRetrieve', 'id', id)
            const localVarPath = `/column_types/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ColumnTypesApi - functional programming interface
 * @export
 */
export const ColumnTypesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ColumnTypesApiAxiosParamCreator(configuration)
    return {
        /**
         *  Column Types are generic Column templates. They hold the metadata for a Column, while the individual Column instances link Column Types to the TimeseriesData they contain.  Some Column Types are innately recognised by Galv and its harvester parsers, while others can be defined by the parsers during data processing.  Searchable fields: - name - description         
         * @summary View Column Types
         * @param {boolean} [isDefault] 
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [unitName] 
         * @param {string} [unitSymbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async columnTypesList(isDefault?: boolean, limit?: number, name?: string, offset?: number, unitName?: string, unitSymbol?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedDataColumnTypeList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.columnTypesList(isDefault, limit, name, offset, unitName, unitSymbol, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Column Types are generic Column templates. They hold the metadata for a Column, while the individual Column instances link Column Types to the TimeseriesData they contain.  Some Column Types are innately recognised by Galv and its harvester parsers, while others can be defined by the parsers during data processing.  Searchable fields: - name - description         
         * @summary View a Column Type
         * @param {number} id A unique integer value identifying this data column type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async columnTypesRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataColumnType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.columnTypesRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ColumnTypesApi - factory interface
 * @export
 */
export const ColumnTypesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ColumnTypesApiFp(configuration)
    return {
        /**
         *  Column Types are generic Column templates. They hold the metadata for a Column, while the individual Column instances link Column Types to the TimeseriesData they contain.  Some Column Types are innately recognised by Galv and its harvester parsers, while others can be defined by the parsers during data processing.  Searchable fields: - name - description         
         * @summary View Column Types
         * @param {boolean} [isDefault] 
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [unitName] 
         * @param {string} [unitSymbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        columnTypesList(isDefault?: boolean, limit?: number, name?: string, offset?: number, unitName?: string, unitSymbol?: string, options?: any): AxiosPromise<PaginatedDataColumnTypeList> {
            return localVarFp.columnTypesList(isDefault, limit, name, offset, unitName, unitSymbol, options).then((request) => request(axios, basePath));
        },
        /**
         *  Column Types are generic Column templates. They hold the metadata for a Column, while the individual Column instances link Column Types to the TimeseriesData they contain.  Some Column Types are innately recognised by Galv and its harvester parsers, while others can be defined by the parsers during data processing.  Searchable fields: - name - description         
         * @summary View a Column Type
         * @param {number} id A unique integer value identifying this data column type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        columnTypesRetrieve(id: number, options?: any): AxiosPromise<DataColumnType> {
            return localVarFp.columnTypesRetrieve(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ColumnTypesApi - object-oriented interface
 * @export
 * @class ColumnTypesApi
 * @extends {BaseAPI}
 */
export class ColumnTypesApi extends BaseAPI {
    /**
     *  Column Types are generic Column templates. They hold the metadata for a Column, while the individual Column instances link Column Types to the TimeseriesData they contain.  Some Column Types are innately recognised by Galv and its harvester parsers, while others can be defined by the parsers during data processing.  Searchable fields: - name - description         
     * @summary View Column Types
     * @param {boolean} [isDefault] 
     * @param {number} [limit] Number of results to return per page.
     * @param {string} [name] 
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [unitName] 
     * @param {string} [unitSymbol] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ColumnTypesApi
     */
    public columnTypesList(isDefault?: boolean, limit?: number, name?: string, offset?: number, unitName?: string, unitSymbol?: string, options?: AxiosRequestConfig) {
        return ColumnTypesApiFp(this.configuration).columnTypesList(isDefault, limit, name, offset, unitName, unitSymbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Column Types are generic Column templates. They hold the metadata for a Column, while the individual Column instances link Column Types to the TimeseriesData they contain.  Some Column Types are innately recognised by Galv and its harvester parsers, while others can be defined by the parsers during data processing.  Searchable fields: - name - description         
     * @summary View a Column Type
     * @param {number} id A unique integer value identifying this data column type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ColumnTypesApi
     */
    public columnTypesRetrieve(id: number, options?: AxiosRequestConfig) {
        return ColumnTypesApiFp(this.configuration).columnTypesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ColumnsApi - axios parameter creator
 * @export
 */
export const ColumnsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Column instances link Column Types to the TimeseriesData they contain. You can access any Column in any Dataset to which you have access.  Searchable fields: - dataset__name - type__name (Column Type name)         
         * @summary View Columns to which you have access
         * @param {string} [fileName] 
         * @param {string} [fileUuid] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {number} [typeId] 
         * @param {string} [typeName] 
         * @param {string} [typeUnitSymbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        columnsList: async (fileName?: string, fileUuid?: string, limit?: number, offset?: number, typeId?: number, typeName?: string, typeUnitSymbol?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/columns/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fileName !== undefined) {
                localVarQueryParameter['file__name'] = fileName;
            }

            if (fileUuid !== undefined) {
                localVarQueryParameter['file__uuid'] = fileUuid;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (typeId !== undefined) {
                localVarQueryParameter['type__id'] = typeId;
            }

            if (typeName !== undefined) {
                localVarQueryParameter['type__name'] = typeName;
            }

            if (typeUnitSymbol !== undefined) {
                localVarQueryParameter['type__unit__symbol'] = typeUnitSymbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Column instances link Column Types to the TimeseriesData they contain.  Searchable fields: - dataset__name - type__name (Column Type name)         
         * @summary View a Column
         * @param {number} id A unique integer value identifying this data column.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        columnsRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('columnsRetrieve', 'id', id)
            const localVarPath = `/columns/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  View the TimeseriesData contents of the Column.  Data are presented as a stream of values separated by newlines.  Can be filtered with querystring parameters `min` and `max`, and `mod` (modulo) by specifying a sample number.         
         * @summary View Column data as newline-separated stream of values
         * @param {number} id A unique integer value identifying this data column.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        columnsValuesRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('columnsValuesRetrieve', 'id', id)
            const localVarPath = `/columns/{id}/values/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ColumnsApi - functional programming interface
 * @export
 */
export const ColumnsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ColumnsApiAxiosParamCreator(configuration)
    return {
        /**
         *  Column instances link Column Types to the TimeseriesData they contain. You can access any Column in any Dataset to which you have access.  Searchable fields: - dataset__name - type__name (Column Type name)         
         * @summary View Columns to which you have access
         * @param {string} [fileName] 
         * @param {string} [fileUuid] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {number} [typeId] 
         * @param {string} [typeName] 
         * @param {string} [typeUnitSymbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async columnsList(fileName?: string, fileUuid?: string, limit?: number, offset?: number, typeId?: number, typeName?: string, typeUnitSymbol?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedDataColumnList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.columnsList(fileName, fileUuid, limit, offset, typeId, typeName, typeUnitSymbol, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Column instances link Column Types to the TimeseriesData they contain.  Searchable fields: - dataset__name - type__name (Column Type name)         
         * @summary View a Column
         * @param {number} id A unique integer value identifying this data column.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async columnsRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataColumn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.columnsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  View the TimeseriesData contents of the Column.  Data are presented as a stream of values separated by newlines.  Can be filtered with querystring parameters `min` and `max`, and `mod` (modulo) by specifying a sample number.         
         * @summary View Column data as newline-separated stream of values
         * @param {number} id A unique integer value identifying this data column.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async columnsValuesRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataColumn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.columnsValuesRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ColumnsApi - factory interface
 * @export
 */
export const ColumnsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ColumnsApiFp(configuration)
    return {
        /**
         *  Column instances link Column Types to the TimeseriesData they contain. You can access any Column in any Dataset to which you have access.  Searchable fields: - dataset__name - type__name (Column Type name)         
         * @summary View Columns to which you have access
         * @param {string} [fileName] 
         * @param {string} [fileUuid] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {number} [typeId] 
         * @param {string} [typeName] 
         * @param {string} [typeUnitSymbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        columnsList(fileName?: string, fileUuid?: string, limit?: number, offset?: number, typeId?: number, typeName?: string, typeUnitSymbol?: string, options?: any): AxiosPromise<PaginatedDataColumnList> {
            return localVarFp.columnsList(fileName, fileUuid, limit, offset, typeId, typeName, typeUnitSymbol, options).then((request) => request(axios, basePath));
        },
        /**
         *  Column instances link Column Types to the TimeseriesData they contain.  Searchable fields: - dataset__name - type__name (Column Type name)         
         * @summary View a Column
         * @param {number} id A unique integer value identifying this data column.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        columnsRetrieve(id: number, options?: any): AxiosPromise<DataColumn> {
            return localVarFp.columnsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  View the TimeseriesData contents of the Column.  Data are presented as a stream of values separated by newlines.  Can be filtered with querystring parameters `min` and `max`, and `mod` (modulo) by specifying a sample number.         
         * @summary View Column data as newline-separated stream of values
         * @param {number} id A unique integer value identifying this data column.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        columnsValuesRetrieve(id: number, options?: any): AxiosPromise<DataColumn> {
            return localVarFp.columnsValuesRetrieve(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ColumnsApi - object-oriented interface
 * @export
 * @class ColumnsApi
 * @extends {BaseAPI}
 */
export class ColumnsApi extends BaseAPI {
    /**
     *  Column instances link Column Types to the TimeseriesData they contain. You can access any Column in any Dataset to which you have access.  Searchable fields: - dataset__name - type__name (Column Type name)         
     * @summary View Columns to which you have access
     * @param {string} [fileName] 
     * @param {string} [fileUuid] 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {number} [typeId] 
     * @param {string} [typeName] 
     * @param {string} [typeUnitSymbol] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ColumnsApi
     */
    public columnsList(fileName?: string, fileUuid?: string, limit?: number, offset?: number, typeId?: number, typeName?: string, typeUnitSymbol?: string, options?: AxiosRequestConfig) {
        return ColumnsApiFp(this.configuration).columnsList(fileName, fileUuid, limit, offset, typeId, typeName, typeUnitSymbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Column instances link Column Types to the TimeseriesData they contain.  Searchable fields: - dataset__name - type__name (Column Type name)         
     * @summary View a Column
     * @param {number} id A unique integer value identifying this data column.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ColumnsApi
     */
    public columnsRetrieve(id: number, options?: AxiosRequestConfig) {
        return ColumnsApiFp(this.configuration).columnsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  View the TimeseriesData contents of the Column.  Data are presented as a stream of values separated by newlines.  Can be filtered with querystring parameters `min` and `max`, and `mod` (modulo) by specifying a sample number.         
     * @summary View Column data as newline-separated stream of values
     * @param {number} id A unique integer value identifying this data column.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ColumnsApi
     */
    public columnsValuesRetrieve(id: number, options?: AxiosRequestConfig) {
        return ColumnsApiFp(this.configuration).columnsValuesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CreateTokenApi - axios parameter creator
 * @export
 */
export const CreateTokenApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Access to the API is authenticated by API Tokens. When you log into the web frontend, you are issued with a temporary token to allow your browser session to function. If you wish to access the API via the Python client, or similar programmatically routes, you will likely want a token with a longer expiry time. Those tokens are created using this endpoint.     
         * @summary Create a new API Token
         * @param {CreateKnoxToken} createKnoxToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTokenCreate: async (createKnoxToken: CreateKnoxToken, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createKnoxToken' is not null or undefined
            assertParamExists('createTokenCreate', 'createKnoxToken', createKnoxToken)
            const localVarPath = `/create_token/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createKnoxToken, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CreateTokenApi - functional programming interface
 * @export
 */
export const CreateTokenApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CreateTokenApiAxiosParamCreator(configuration)
    return {
        /**
         *  Access to the API is authenticated by API Tokens. When you log into the web frontend, you are issued with a temporary token to allow your browser session to function. If you wish to access the API via the Python client, or similar programmatically routes, you will likely want a token with a longer expiry time. Those tokens are created using this endpoint.     
         * @summary Create a new API Token
         * @param {CreateKnoxToken} createKnoxToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTokenCreate(createKnoxToken: CreateKnoxToken, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KnoxTokenFull>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTokenCreate(createKnoxToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CreateTokenApi - factory interface
 * @export
 */
export const CreateTokenApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CreateTokenApiFp(configuration)
    return {
        /**
         *  Access to the API is authenticated by API Tokens. When you log into the web frontend, you are issued with a temporary token to allow your browser session to function. If you wish to access the API via the Python client, or similar programmatically routes, you will likely want a token with a longer expiry time. Those tokens are created using this endpoint.     
         * @summary Create a new API Token
         * @param {CreateKnoxToken} createKnoxToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTokenCreate(createKnoxToken: CreateKnoxToken, options?: any): AxiosPromise<KnoxTokenFull> {
            return localVarFp.createTokenCreate(createKnoxToken, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CreateTokenApi - object-oriented interface
 * @export
 * @class CreateTokenApi
 * @extends {BaseAPI}
 */
export class CreateTokenApi extends BaseAPI {
    /**
     *  Access to the API is authenticated by API Tokens. When you log into the web frontend, you are issued with a temporary token to allow your browser session to function. If you wish to access the API via the Python client, or similar programmatically routes, you will likely want a token with a longer expiry time. Those tokens are created using this endpoint.     
     * @summary Create a new API Token
     * @param {CreateKnoxToken} createKnoxToken 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreateTokenApi
     */
    public createTokenCreate(createKnoxToken: CreateKnoxToken, options?: AxiosRequestConfig) {
        return CreateTokenApiFp(this.configuration).createTokenCreate(createKnoxToken, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CyclerTestsApi - axios parameter creator
 * @export
 */
export const CyclerTestsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cycler Tests are the primary object in the database. They represent a single test conducted on a specific cell using specific equipment, according to a specific schedule.  The test produces a dataset which can be associated with the Cycler Test, and Cycler Tests can be grouped together into Experiments.
         * @param {CyclerTest} cyclerTest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cyclerTestsCreate: async (cyclerTest: CyclerTest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cyclerTest' is not null or undefined
            assertParamExists('cyclerTestsCreate', 'cyclerTest', cyclerTest)
            const localVarPath = `/cycler_tests/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cyclerTest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cycler Tests are the primary object in the database. They represent a single test conducted on a specific cell using specific equipment, according to a specific schedule.  The test produces a dataset which can be associated with the Cycler Test, and Cycler Tests can be grouped together into Experiments.
         * @param {string} uuid A UUID string identifying this cycler test.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cyclerTestsDestroy: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('cyclerTestsDestroy', 'uuid', uuid)
            const localVarPath = `/cycler_tests/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cycler Tests are the primary object in the database. They represent a single test conducted on a specific cell using specific equipment, according to a specific schedule.  The test produces a dataset which can be associated with the Cycler Test, and Cycler Tests can be grouped together into Experiments.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cyclerTestsList: async (limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cycler_tests/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cycler Tests are the primary object in the database. They represent a single test conducted on a specific cell using specific equipment, according to a specific schedule.  The test produces a dataset which can be associated with the Cycler Test, and Cycler Tests can be grouped together into Experiments.
         * @param {string} uuid A UUID string identifying this cycler test.
         * @param {PatchedCyclerTest} [patchedCyclerTest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cyclerTestsPartialUpdate: async (uuid: string, patchedCyclerTest?: PatchedCyclerTest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('cyclerTestsPartialUpdate', 'uuid', uuid)
            const localVarPath = `/cycler_tests/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedCyclerTest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cycler Tests are the primary object in the database. They represent a single test conducted on a specific cell using specific equipment, according to a specific schedule.  The test produces a dataset which can be associated with the Cycler Test, and Cycler Tests can be grouped together into Experiments.
         * @param {string} uuid A UUID string identifying this cycler test.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cyclerTestsRetrieve: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('cyclerTestsRetrieve', 'uuid', uuid)
            const localVarPath = `/cycler_tests/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cycler Tests are the primary object in the database. They represent a single test conducted on a specific cell using specific equipment, according to a specific schedule.  The test produces a dataset which can be associated with the Cycler Test, and Cycler Tests can be grouped together into Experiments.
         * @param {string} uuid A UUID string identifying this cycler test.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cyclerTestsWithValidationRetrieve: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('cyclerTestsWithValidationRetrieve', 'uuid', uuid)
            const localVarPath = `/cycler_tests/{uuid}/with_validation/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CyclerTestsApi - functional programming interface
 * @export
 */
export const CyclerTestsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CyclerTestsApiAxiosParamCreator(configuration)
    return {
        /**
         * Cycler Tests are the primary object in the database. They represent a single test conducted on a specific cell using specific equipment, according to a specific schedule.  The test produces a dataset which can be associated with the Cycler Test, and Cycler Tests can be grouped together into Experiments.
         * @param {CyclerTest} cyclerTest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cyclerTestsCreate(cyclerTest: CyclerTest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CyclerTest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cyclerTestsCreate(cyclerTest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Cycler Tests are the primary object in the database. They represent a single test conducted on a specific cell using specific equipment, according to a specific schedule.  The test produces a dataset which can be associated with the Cycler Test, and Cycler Tests can be grouped together into Experiments.
         * @param {string} uuid A UUID string identifying this cycler test.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cyclerTestsDestroy(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cyclerTestsDestroy(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Cycler Tests are the primary object in the database. They represent a single test conducted on a specific cell using specific equipment, according to a specific schedule.  The test produces a dataset which can be associated with the Cycler Test, and Cycler Tests can be grouped together into Experiments.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cyclerTestsList(limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedCyclerTestList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cyclerTestsList(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Cycler Tests are the primary object in the database. They represent a single test conducted on a specific cell using specific equipment, according to a specific schedule.  The test produces a dataset which can be associated with the Cycler Test, and Cycler Tests can be grouped together into Experiments.
         * @param {string} uuid A UUID string identifying this cycler test.
         * @param {PatchedCyclerTest} [patchedCyclerTest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cyclerTestsPartialUpdate(uuid: string, patchedCyclerTest?: PatchedCyclerTest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CyclerTest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cyclerTestsPartialUpdate(uuid, patchedCyclerTest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Cycler Tests are the primary object in the database. They represent a single test conducted on a specific cell using specific equipment, according to a specific schedule.  The test produces a dataset which can be associated with the Cycler Test, and Cycler Tests can be grouped together into Experiments.
         * @param {string} uuid A UUID string identifying this cycler test.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cyclerTestsRetrieve(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CyclerTest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cyclerTestsRetrieve(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Cycler Tests are the primary object in the database. They represent a single test conducted on a specific cell using specific equipment, according to a specific schedule.  The test produces a dataset which can be associated with the Cycler Test, and Cycler Tests can be grouped together into Experiments.
         * @param {string} uuid A UUID string identifying this cycler test.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cyclerTestsWithValidationRetrieve(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CyclerTest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cyclerTestsWithValidationRetrieve(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CyclerTestsApi - factory interface
 * @export
 */
export const CyclerTestsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CyclerTestsApiFp(configuration)
    return {
        /**
         * Cycler Tests are the primary object in the database. They represent a single test conducted on a specific cell using specific equipment, according to a specific schedule.  The test produces a dataset which can be associated with the Cycler Test, and Cycler Tests can be grouped together into Experiments.
         * @param {CyclerTest} cyclerTest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cyclerTestsCreate(cyclerTest: CyclerTest, options?: any): AxiosPromise<CyclerTest> {
            return localVarFp.cyclerTestsCreate(cyclerTest, options).then((request) => request(axios, basePath));
        },
        /**
         * Cycler Tests are the primary object in the database. They represent a single test conducted on a specific cell using specific equipment, according to a specific schedule.  The test produces a dataset which can be associated with the Cycler Test, and Cycler Tests can be grouped together into Experiments.
         * @param {string} uuid A UUID string identifying this cycler test.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cyclerTestsDestroy(uuid: string, options?: any): AxiosPromise<void> {
            return localVarFp.cyclerTestsDestroy(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Cycler Tests are the primary object in the database. They represent a single test conducted on a specific cell using specific equipment, according to a specific schedule.  The test produces a dataset which can be associated with the Cycler Test, and Cycler Tests can be grouped together into Experiments.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cyclerTestsList(limit?: number, offset?: number, options?: any): AxiosPromise<PaginatedCyclerTestList> {
            return localVarFp.cyclerTestsList(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Cycler Tests are the primary object in the database. They represent a single test conducted on a specific cell using specific equipment, according to a specific schedule.  The test produces a dataset which can be associated with the Cycler Test, and Cycler Tests can be grouped together into Experiments.
         * @param {string} uuid A UUID string identifying this cycler test.
         * @param {PatchedCyclerTest} [patchedCyclerTest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cyclerTestsPartialUpdate(uuid: string, patchedCyclerTest?: PatchedCyclerTest, options?: any): AxiosPromise<CyclerTest> {
            return localVarFp.cyclerTestsPartialUpdate(uuid, patchedCyclerTest, options).then((request) => request(axios, basePath));
        },
        /**
         * Cycler Tests are the primary object in the database. They represent a single test conducted on a specific cell using specific equipment, according to a specific schedule.  The test produces a dataset which can be associated with the Cycler Test, and Cycler Tests can be grouped together into Experiments.
         * @param {string} uuid A UUID string identifying this cycler test.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cyclerTestsRetrieve(uuid: string, options?: any): AxiosPromise<CyclerTest> {
            return localVarFp.cyclerTestsRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Cycler Tests are the primary object in the database. They represent a single test conducted on a specific cell using specific equipment, according to a specific schedule.  The test produces a dataset which can be associated with the Cycler Test, and Cycler Tests can be grouped together into Experiments.
         * @param {string} uuid A UUID string identifying this cycler test.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cyclerTestsWithValidationRetrieve(uuid: string, options?: any): AxiosPromise<CyclerTest> {
            return localVarFp.cyclerTestsWithValidationRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CyclerTestsApi - object-oriented interface
 * @export
 * @class CyclerTestsApi
 * @extends {BaseAPI}
 */
export class CyclerTestsApi extends BaseAPI {
    /**
     * Cycler Tests are the primary object in the database. They represent a single test conducted on a specific cell using specific equipment, according to a specific schedule.  The test produces a dataset which can be associated with the Cycler Test, and Cycler Tests can be grouped together into Experiments.
     * @param {CyclerTest} cyclerTest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CyclerTestsApi
     */
    public cyclerTestsCreate(cyclerTest: CyclerTest, options?: AxiosRequestConfig) {
        return CyclerTestsApiFp(this.configuration).cyclerTestsCreate(cyclerTest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cycler Tests are the primary object in the database. They represent a single test conducted on a specific cell using specific equipment, according to a specific schedule.  The test produces a dataset which can be associated with the Cycler Test, and Cycler Tests can be grouped together into Experiments.
     * @param {string} uuid A UUID string identifying this cycler test.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CyclerTestsApi
     */
    public cyclerTestsDestroy(uuid: string, options?: AxiosRequestConfig) {
        return CyclerTestsApiFp(this.configuration).cyclerTestsDestroy(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cycler Tests are the primary object in the database. They represent a single test conducted on a specific cell using specific equipment, according to a specific schedule.  The test produces a dataset which can be associated with the Cycler Test, and Cycler Tests can be grouped together into Experiments.
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CyclerTestsApi
     */
    public cyclerTestsList(limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return CyclerTestsApiFp(this.configuration).cyclerTestsList(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cycler Tests are the primary object in the database. They represent a single test conducted on a specific cell using specific equipment, according to a specific schedule.  The test produces a dataset which can be associated with the Cycler Test, and Cycler Tests can be grouped together into Experiments.
     * @param {string} uuid A UUID string identifying this cycler test.
     * @param {PatchedCyclerTest} [patchedCyclerTest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CyclerTestsApi
     */
    public cyclerTestsPartialUpdate(uuid: string, patchedCyclerTest?: PatchedCyclerTest, options?: AxiosRequestConfig) {
        return CyclerTestsApiFp(this.configuration).cyclerTestsPartialUpdate(uuid, patchedCyclerTest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cycler Tests are the primary object in the database. They represent a single test conducted on a specific cell using specific equipment, according to a specific schedule.  The test produces a dataset which can be associated with the Cycler Test, and Cycler Tests can be grouped together into Experiments.
     * @param {string} uuid A UUID string identifying this cycler test.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CyclerTestsApi
     */
    public cyclerTestsRetrieve(uuid: string, options?: AxiosRequestConfig) {
        return CyclerTestsApiFp(this.configuration).cyclerTestsRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cycler Tests are the primary object in the database. They represent a single test conducted on a specific cell using specific equipment, according to a specific schedule.  The test produces a dataset which can be associated with the Cycler Test, and Cycler Tests can be grouped together into Experiments.
     * @param {string} uuid A UUID string identifying this cycler test.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CyclerTestsApi
     */
    public cyclerTestsWithValidationRetrieve(uuid: string, options?: AxiosRequestConfig) {
        return CyclerTestsApiFp(this.configuration).cyclerTestsWithValidationRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EquipmentApi - axios parameter creator
 * @export
 */
export const EquipmentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Create Equipment by describing its role and purpose.         
         * @summary Create Equipment
         * @param {Equipment} equipment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        equipmentCreate: async (equipment: Equipment, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'equipment' is not null or undefined
            assertParamExists('equipmentCreate', 'equipment', equipment)
            const localVarPath = `/equipment/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(equipment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Equipment that is not used in Cycler Tests may be deleted. Equipment that _is_ used in a Cycler Tests is locked to prevent accidental updating.         
         * @summary Delete Equipment
         * @param {string} uuid A UUID string identifying this equipment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        equipmentDestroy: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('equipmentDestroy', 'uuid', uuid)
            const localVarPath = `/equipment/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Experimental equipment used in experiments which generate Files and their Cycler Tests.  Searchable fields: - name - type         
         * @summary View Equipment
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        equipmentList: async (limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/equipment/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Equipment that is not used in Cycler Tests may be edited. Equipment that _is_ used in a Cycler Tests is locked to prevent accidental updating.         
         * @summary Update Equipment
         * @param {string} uuid A UUID string identifying this equipment.
         * @param {PatchedEquipment} [patchedEquipment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        equipmentPartialUpdate: async (uuid: string, patchedEquipment?: PatchedEquipment, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('equipmentPartialUpdate', 'uuid', uuid)
            const localVarPath = `/equipment/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedEquipment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Experimental equipment used in experiments which generate Files and their Cycler Tests.         
         * @summary View specific Equipment
         * @param {string} uuid A UUID string identifying this equipment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        equipmentRetrieve: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('equipmentRetrieve', 'uuid', uuid)
            const localVarPath = `/equipment/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Equipment can be attached to Datasets and used to view Datasets which have used similar equipment.
         * @param {string} uuid A UUID string identifying this equipment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        equipmentWithValidationRetrieve: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('equipmentWithValidationRetrieve', 'uuid', uuid)
            const localVarPath = `/equipment/{uuid}/with_validation/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EquipmentApi - functional programming interface
 * @export
 */
export const EquipmentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EquipmentApiAxiosParamCreator(configuration)
    return {
        /**
         *  Create Equipment by describing its role and purpose.         
         * @summary Create Equipment
         * @param {Equipment} equipment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async equipmentCreate(equipment: Equipment, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Equipment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.equipmentCreate(equipment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Equipment that is not used in Cycler Tests may be deleted. Equipment that _is_ used in a Cycler Tests is locked to prevent accidental updating.         
         * @summary Delete Equipment
         * @param {string} uuid A UUID string identifying this equipment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async equipmentDestroy(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.equipmentDestroy(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Experimental equipment used in experiments which generate Files and their Cycler Tests.  Searchable fields: - name - type         
         * @summary View Equipment
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async equipmentList(limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedEquipmentList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.equipmentList(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Equipment that is not used in Cycler Tests may be edited. Equipment that _is_ used in a Cycler Tests is locked to prevent accidental updating.         
         * @summary Update Equipment
         * @param {string} uuid A UUID string identifying this equipment.
         * @param {PatchedEquipment} [patchedEquipment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async equipmentPartialUpdate(uuid: string, patchedEquipment?: PatchedEquipment, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Equipment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.equipmentPartialUpdate(uuid, patchedEquipment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Experimental equipment used in experiments which generate Files and their Cycler Tests.         
         * @summary View specific Equipment
         * @param {string} uuid A UUID string identifying this equipment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async equipmentRetrieve(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Equipment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.equipmentRetrieve(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Equipment can be attached to Datasets and used to view Datasets which have used similar equipment.
         * @param {string} uuid A UUID string identifying this equipment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async equipmentWithValidationRetrieve(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Equipment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.equipmentWithValidationRetrieve(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EquipmentApi - factory interface
 * @export
 */
export const EquipmentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EquipmentApiFp(configuration)
    return {
        /**
         *  Create Equipment by describing its role and purpose.         
         * @summary Create Equipment
         * @param {Equipment} equipment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        equipmentCreate(equipment: Equipment, options?: any): AxiosPromise<Equipment> {
            return localVarFp.equipmentCreate(equipment, options).then((request) => request(axios, basePath));
        },
        /**
         *  Equipment that is not used in Cycler Tests may be deleted. Equipment that _is_ used in a Cycler Tests is locked to prevent accidental updating.         
         * @summary Delete Equipment
         * @param {string} uuid A UUID string identifying this equipment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        equipmentDestroy(uuid: string, options?: any): AxiosPromise<void> {
            return localVarFp.equipmentDestroy(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         *  Experimental equipment used in experiments which generate Files and their Cycler Tests.  Searchable fields: - name - type         
         * @summary View Equipment
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        equipmentList(limit?: number, offset?: number, options?: any): AxiosPromise<PaginatedEquipmentList> {
            return localVarFp.equipmentList(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         *  Equipment that is not used in Cycler Tests may be edited. Equipment that _is_ used in a Cycler Tests is locked to prevent accidental updating.         
         * @summary Update Equipment
         * @param {string} uuid A UUID string identifying this equipment.
         * @param {PatchedEquipment} [patchedEquipment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        equipmentPartialUpdate(uuid: string, patchedEquipment?: PatchedEquipment, options?: any): AxiosPromise<Equipment> {
            return localVarFp.equipmentPartialUpdate(uuid, patchedEquipment, options).then((request) => request(axios, basePath));
        },
        /**
         *  Experimental equipment used in experiments which generate Files and their Cycler Tests.         
         * @summary View specific Equipment
         * @param {string} uuid A UUID string identifying this equipment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        equipmentRetrieve(uuid: string, options?: any): AxiosPromise<Equipment> {
            return localVarFp.equipmentRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Equipment can be attached to Datasets and used to view Datasets which have used similar equipment.
         * @param {string} uuid A UUID string identifying this equipment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        equipmentWithValidationRetrieve(uuid: string, options?: any): AxiosPromise<Equipment> {
            return localVarFp.equipmentWithValidationRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EquipmentApi - object-oriented interface
 * @export
 * @class EquipmentApi
 * @extends {BaseAPI}
 */
export class EquipmentApi extends BaseAPI {
    /**
     *  Create Equipment by describing its role and purpose.         
     * @summary Create Equipment
     * @param {Equipment} equipment 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EquipmentApi
     */
    public equipmentCreate(equipment: Equipment, options?: AxiosRequestConfig) {
        return EquipmentApiFp(this.configuration).equipmentCreate(equipment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Equipment that is not used in Cycler Tests may be deleted. Equipment that _is_ used in a Cycler Tests is locked to prevent accidental updating.         
     * @summary Delete Equipment
     * @param {string} uuid A UUID string identifying this equipment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EquipmentApi
     */
    public equipmentDestroy(uuid: string, options?: AxiosRequestConfig) {
        return EquipmentApiFp(this.configuration).equipmentDestroy(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Experimental equipment used in experiments which generate Files and their Cycler Tests.  Searchable fields: - name - type         
     * @summary View Equipment
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EquipmentApi
     */
    public equipmentList(limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return EquipmentApiFp(this.configuration).equipmentList(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Equipment that is not used in Cycler Tests may be edited. Equipment that _is_ used in a Cycler Tests is locked to prevent accidental updating.         
     * @summary Update Equipment
     * @param {string} uuid A UUID string identifying this equipment.
     * @param {PatchedEquipment} [patchedEquipment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EquipmentApi
     */
    public equipmentPartialUpdate(uuid: string, patchedEquipment?: PatchedEquipment, options?: AxiosRequestConfig) {
        return EquipmentApiFp(this.configuration).equipmentPartialUpdate(uuid, patchedEquipment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Experimental equipment used in experiments which generate Files and their Cycler Tests.         
     * @summary View specific Equipment
     * @param {string} uuid A UUID string identifying this equipment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EquipmentApi
     */
    public equipmentRetrieve(uuid: string, options?: AxiosRequestConfig) {
        return EquipmentApiFp(this.configuration).equipmentRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Equipment can be attached to Datasets and used to view Datasets which have used similar equipment.
     * @param {string} uuid A UUID string identifying this equipment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EquipmentApi
     */
    public equipmentWithValidationRetrieve(uuid: string, options?: AxiosRequestConfig) {
        return EquipmentApiFp(this.configuration).equipmentWithValidationRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EquipmentFamiliesApi - axios parameter creator
 * @export
 */
export const EquipmentFamiliesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Equipment Families group together the general properties of a type of Equipment. Each Equipment is associated with an Equipment Family.         
         * @summary Create an Equipment Family
         * @param {EquipmentFamily} equipmentFamily 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        equipmentFamiliesCreate: async (equipmentFamily: EquipmentFamily, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'equipmentFamily' is not null or undefined
            assertParamExists('equipmentFamiliesCreate', 'equipmentFamily', equipmentFamily)
            const localVarPath = `/equipment_families/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(equipmentFamily, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Equipment Families that do not have any Equipment associated with them may be deleted. Equipment Families that _do_ have Equipment associated with them are locked, to prevent accidental updating.         
         * @summary Delete an Equipment Family
         * @param {string} uuid A UUID string identifying this equipment family.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        equipmentFamiliesDestroy: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('equipmentFamiliesDestroy', 'uuid', uuid)
            const localVarPath = `/equipment_families/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Equipment Families group together the general properties of a type of Equipment. Each Equipment is associated with an Equipment Family.  Searchable fields: - type - manufacturer - form_factor         
         * @summary View Equipment Families
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        equipmentFamiliesList: async (limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/equipment_families/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Equipment Families that do not have any Equipment associated with them may be edited. Equipment Families that _do_ have Equipment associated with them are locked, to prevent accidental updating.         
         * @summary Update an Equipment Family
         * @param {string} uuid A UUID string identifying this equipment family.
         * @param {PatchedEquipmentFamily} [patchedEquipmentFamily] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        equipmentFamiliesPartialUpdate: async (uuid: string, patchedEquipmentFamily?: PatchedEquipmentFamily, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('equipmentFamiliesPartialUpdate', 'uuid', uuid)
            const localVarPath = `/equipment_families/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedEquipmentFamily, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Equipment Families group together the general properties of a type of Equipment. Each Equipment is associated with an Equipment Family.         
         * @summary View an Equipment Family
         * @param {string} uuid A UUID string identifying this equipment family.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        equipmentFamiliesRetrieve: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('equipmentFamiliesRetrieve', 'uuid', uuid)
            const localVarPath = `/equipment_families/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * EquipmentFamilies describe types of Equipment.
         * @param {string} uuid A UUID string identifying this equipment family.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        equipmentFamiliesWithValidationRetrieve: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('equipmentFamiliesWithValidationRetrieve', 'uuid', uuid)
            const localVarPath = `/equipment_families/{uuid}/with_validation/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EquipmentFamiliesApi - functional programming interface
 * @export
 */
export const EquipmentFamiliesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EquipmentFamiliesApiAxiosParamCreator(configuration)
    return {
        /**
         *  Equipment Families group together the general properties of a type of Equipment. Each Equipment is associated with an Equipment Family.         
         * @summary Create an Equipment Family
         * @param {EquipmentFamily} equipmentFamily 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async equipmentFamiliesCreate(equipmentFamily: EquipmentFamily, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EquipmentFamily>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.equipmentFamiliesCreate(equipmentFamily, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Equipment Families that do not have any Equipment associated with them may be deleted. Equipment Families that _do_ have Equipment associated with them are locked, to prevent accidental updating.         
         * @summary Delete an Equipment Family
         * @param {string} uuid A UUID string identifying this equipment family.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async equipmentFamiliesDestroy(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.equipmentFamiliesDestroy(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Equipment Families group together the general properties of a type of Equipment. Each Equipment is associated with an Equipment Family.  Searchable fields: - type - manufacturer - form_factor         
         * @summary View Equipment Families
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async equipmentFamiliesList(limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedEquipmentFamilyList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.equipmentFamiliesList(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Equipment Families that do not have any Equipment associated with them may be edited. Equipment Families that _do_ have Equipment associated with them are locked, to prevent accidental updating.         
         * @summary Update an Equipment Family
         * @param {string} uuid A UUID string identifying this equipment family.
         * @param {PatchedEquipmentFamily} [patchedEquipmentFamily] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async equipmentFamiliesPartialUpdate(uuid: string, patchedEquipmentFamily?: PatchedEquipmentFamily, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EquipmentFamily>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.equipmentFamiliesPartialUpdate(uuid, patchedEquipmentFamily, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Equipment Families group together the general properties of a type of Equipment. Each Equipment is associated with an Equipment Family.         
         * @summary View an Equipment Family
         * @param {string} uuid A UUID string identifying this equipment family.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async equipmentFamiliesRetrieve(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EquipmentFamily>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.equipmentFamiliesRetrieve(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * EquipmentFamilies describe types of Equipment.
         * @param {string} uuid A UUID string identifying this equipment family.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async equipmentFamiliesWithValidationRetrieve(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EquipmentFamily>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.equipmentFamiliesWithValidationRetrieve(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EquipmentFamiliesApi - factory interface
 * @export
 */
export const EquipmentFamiliesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EquipmentFamiliesApiFp(configuration)
    return {
        /**
         *  Equipment Families group together the general properties of a type of Equipment. Each Equipment is associated with an Equipment Family.         
         * @summary Create an Equipment Family
         * @param {EquipmentFamily} equipmentFamily 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        equipmentFamiliesCreate(equipmentFamily: EquipmentFamily, options?: any): AxiosPromise<EquipmentFamily> {
            return localVarFp.equipmentFamiliesCreate(equipmentFamily, options).then((request) => request(axios, basePath));
        },
        /**
         *  Equipment Families that do not have any Equipment associated with them may be deleted. Equipment Families that _do_ have Equipment associated with them are locked, to prevent accidental updating.         
         * @summary Delete an Equipment Family
         * @param {string} uuid A UUID string identifying this equipment family.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        equipmentFamiliesDestroy(uuid: string, options?: any): AxiosPromise<void> {
            return localVarFp.equipmentFamiliesDestroy(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         *  Equipment Families group together the general properties of a type of Equipment. Each Equipment is associated with an Equipment Family.  Searchable fields: - type - manufacturer - form_factor         
         * @summary View Equipment Families
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        equipmentFamiliesList(limit?: number, offset?: number, options?: any): AxiosPromise<PaginatedEquipmentFamilyList> {
            return localVarFp.equipmentFamiliesList(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         *  Equipment Families that do not have any Equipment associated with them may be edited. Equipment Families that _do_ have Equipment associated with them are locked, to prevent accidental updating.         
         * @summary Update an Equipment Family
         * @param {string} uuid A UUID string identifying this equipment family.
         * @param {PatchedEquipmentFamily} [patchedEquipmentFamily] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        equipmentFamiliesPartialUpdate(uuid: string, patchedEquipmentFamily?: PatchedEquipmentFamily, options?: any): AxiosPromise<EquipmentFamily> {
            return localVarFp.equipmentFamiliesPartialUpdate(uuid, patchedEquipmentFamily, options).then((request) => request(axios, basePath));
        },
        /**
         *  Equipment Families group together the general properties of a type of Equipment. Each Equipment is associated with an Equipment Family.         
         * @summary View an Equipment Family
         * @param {string} uuid A UUID string identifying this equipment family.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        equipmentFamiliesRetrieve(uuid: string, options?: any): AxiosPromise<EquipmentFamily> {
            return localVarFp.equipmentFamiliesRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * EquipmentFamilies describe types of Equipment.
         * @param {string} uuid A UUID string identifying this equipment family.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        equipmentFamiliesWithValidationRetrieve(uuid: string, options?: any): AxiosPromise<EquipmentFamily> {
            return localVarFp.equipmentFamiliesWithValidationRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EquipmentFamiliesApi - object-oriented interface
 * @export
 * @class EquipmentFamiliesApi
 * @extends {BaseAPI}
 */
export class EquipmentFamiliesApi extends BaseAPI {
    /**
     *  Equipment Families group together the general properties of a type of Equipment. Each Equipment is associated with an Equipment Family.         
     * @summary Create an Equipment Family
     * @param {EquipmentFamily} equipmentFamily 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EquipmentFamiliesApi
     */
    public equipmentFamiliesCreate(equipmentFamily: EquipmentFamily, options?: AxiosRequestConfig) {
        return EquipmentFamiliesApiFp(this.configuration).equipmentFamiliesCreate(equipmentFamily, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Equipment Families that do not have any Equipment associated with them may be deleted. Equipment Families that _do_ have Equipment associated with them are locked, to prevent accidental updating.         
     * @summary Delete an Equipment Family
     * @param {string} uuid A UUID string identifying this equipment family.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EquipmentFamiliesApi
     */
    public equipmentFamiliesDestroy(uuid: string, options?: AxiosRequestConfig) {
        return EquipmentFamiliesApiFp(this.configuration).equipmentFamiliesDestroy(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Equipment Families group together the general properties of a type of Equipment. Each Equipment is associated with an Equipment Family.  Searchable fields: - type - manufacturer - form_factor         
     * @summary View Equipment Families
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EquipmentFamiliesApi
     */
    public equipmentFamiliesList(limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return EquipmentFamiliesApiFp(this.configuration).equipmentFamiliesList(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Equipment Families that do not have any Equipment associated with them may be edited. Equipment Families that _do_ have Equipment associated with them are locked, to prevent accidental updating.         
     * @summary Update an Equipment Family
     * @param {string} uuid A UUID string identifying this equipment family.
     * @param {PatchedEquipmentFamily} [patchedEquipmentFamily] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EquipmentFamiliesApi
     */
    public equipmentFamiliesPartialUpdate(uuid: string, patchedEquipmentFamily?: PatchedEquipmentFamily, options?: AxiosRequestConfig) {
        return EquipmentFamiliesApiFp(this.configuration).equipmentFamiliesPartialUpdate(uuid, patchedEquipmentFamily, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Equipment Families group together the general properties of a type of Equipment. Each Equipment is associated with an Equipment Family.         
     * @summary View an Equipment Family
     * @param {string} uuid A UUID string identifying this equipment family.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EquipmentFamiliesApi
     */
    public equipmentFamiliesRetrieve(uuid: string, options?: AxiosRequestConfig) {
        return EquipmentFamiliesApiFp(this.configuration).equipmentFamiliesRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * EquipmentFamilies describe types of Equipment.
     * @param {string} uuid A UUID string identifying this equipment family.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EquipmentFamiliesApi
     */
    public equipmentFamiliesWithValidationRetrieve(uuid: string, options?: AxiosRequestConfig) {
        return EquipmentFamiliesApiFp(this.configuration).equipmentFamiliesWithValidationRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EquipmentManufacturersApi - axios parameter creator
 * @export
 */
export const EquipmentManufacturersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Equipment Manufacturers are used to describe the manufacturer of equipment used in an experiment. Examples are \"Arbin\", \"Maccor\".
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        equipmentManufacturersList: async (limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/equipment_manufacturers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EquipmentManufacturersApi - functional programming interface
 * @export
 */
export const EquipmentManufacturersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EquipmentManufacturersApiAxiosParamCreator(configuration)
    return {
        /**
         * Equipment Manufacturers are used to describe the manufacturer of equipment used in an experiment. Examples are \"Arbin\", \"Maccor\".
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async equipmentManufacturersList(limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CellChemistriesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.equipmentManufacturersList(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EquipmentManufacturersApi - factory interface
 * @export
 */
export const EquipmentManufacturersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EquipmentManufacturersApiFp(configuration)
    return {
        /**
         * Equipment Manufacturers are used to describe the manufacturer of equipment used in an experiment. Examples are \"Arbin\", \"Maccor\".
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        equipmentManufacturersList(limit?: number, offset?: number, options?: any): AxiosPromise<CellChemistriesList200Response> {
            return localVarFp.equipmentManufacturersList(limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EquipmentManufacturersApi - object-oriented interface
 * @export
 * @class EquipmentManufacturersApi
 * @extends {BaseAPI}
 */
export class EquipmentManufacturersApi extends BaseAPI {
    /**
     * Equipment Manufacturers are used to describe the manufacturer of equipment used in an experiment. Examples are \"Arbin\", \"Maccor\".
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EquipmentManufacturersApi
     */
    public equipmentManufacturersList(limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return EquipmentManufacturersApiFp(this.configuration).equipmentManufacturersList(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EquipmentModelsApi - axios parameter creator
 * @export
 */
export const EquipmentModelsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Equipment Models are used to describe the model of equipment used in an experiment. Examples are \"BT-2000\", \"BT-2043\".
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        equipmentModelsList: async (limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/equipment_models/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EquipmentModelsApi - functional programming interface
 * @export
 */
export const EquipmentModelsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EquipmentModelsApiAxiosParamCreator(configuration)
    return {
        /**
         * Equipment Models are used to describe the model of equipment used in an experiment. Examples are \"BT-2000\", \"BT-2043\".
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async equipmentModelsList(limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CellChemistriesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.equipmentModelsList(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EquipmentModelsApi - factory interface
 * @export
 */
export const EquipmentModelsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EquipmentModelsApiFp(configuration)
    return {
        /**
         * Equipment Models are used to describe the model of equipment used in an experiment. Examples are \"BT-2000\", \"BT-2043\".
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        equipmentModelsList(limit?: number, offset?: number, options?: any): AxiosPromise<CellChemistriesList200Response> {
            return localVarFp.equipmentModelsList(limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EquipmentModelsApi - object-oriented interface
 * @export
 * @class EquipmentModelsApi
 * @extends {BaseAPI}
 */
export class EquipmentModelsApi extends BaseAPI {
    /**
     * Equipment Models are used to describe the model of equipment used in an experiment. Examples are \"BT-2000\", \"BT-2043\".
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EquipmentModelsApi
     */
    public equipmentModelsList(limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return EquipmentModelsApiFp(this.configuration).equipmentModelsList(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EquipmentTypesApi - axios parameter creator
 * @export
 */
export const EquipmentTypesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Equipment Types are used to describe the type of equipment used in an experiment. Examples are \"Thermal Chamber\", \"Cycler\".
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        equipmentTypesList: async (limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/equipment_types/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EquipmentTypesApi - functional programming interface
 * @export
 */
export const EquipmentTypesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EquipmentTypesApiAxiosParamCreator(configuration)
    return {
        /**
         * Equipment Types are used to describe the type of equipment used in an experiment. Examples are \"Thermal Chamber\", \"Cycler\".
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async equipmentTypesList(limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CellChemistriesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.equipmentTypesList(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EquipmentTypesApi - factory interface
 * @export
 */
export const EquipmentTypesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EquipmentTypesApiFp(configuration)
    return {
        /**
         * Equipment Types are used to describe the type of equipment used in an experiment. Examples are \"Thermal Chamber\", \"Cycler\".
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        equipmentTypesList(limit?: number, offset?: number, options?: any): AxiosPromise<CellChemistriesList200Response> {
            return localVarFp.equipmentTypesList(limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EquipmentTypesApi - object-oriented interface
 * @export
 * @class EquipmentTypesApi
 * @extends {BaseAPI}
 */
export class EquipmentTypesApi extends BaseAPI {
    /**
     * Equipment Types are used to describe the type of equipment used in an experiment. Examples are \"Thermal Chamber\", \"Cycler\".
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EquipmentTypesApi
     */
    public equipmentTypesList(limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return EquipmentTypesApiFp(this.configuration).equipmentTypesList(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ExperimentsApi - axios parameter creator
 * @export
 */
export const ExperimentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Experiments are collections of Cycler Tests which are grouped together for analysis.         
         * @summary Create an Experiment
         * @param {Experiment} experiment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        experimentsCreate: async (experiment: Experiment, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'experiment' is not null or undefined
            assertParamExists('experimentsCreate', 'experiment', experiment)
            const localVarPath = `/experiments/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(experiment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Experiments are collections of Cycler Tests which are grouped together for analysis.
         * @param {string} uuid A UUID string identifying this experiment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        experimentsDestroy: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('experimentsDestroy', 'uuid', uuid)
            const localVarPath = `/experiments/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Experiments are collections of Cycler Tests which are grouped together for analysis.         
         * @summary View Experiments
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        experimentsList: async (limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/experiments/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Experiments are collections of Cycler Tests which are grouped together for analysis.
         * @param {string} uuid A UUID string identifying this experiment.
         * @param {PatchedExperiment} [patchedExperiment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        experimentsPartialUpdate: async (uuid: string, patchedExperiment?: PatchedExperiment, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('experimentsPartialUpdate', 'uuid', uuid)
            const localVarPath = `/experiments/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedExperiment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Experiments are collections of Cycler Tests which are grouped together for analysis.         
         * @summary View an Experiment
         * @param {string} uuid A UUID string identifying this experiment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        experimentsRetrieve: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('experimentsRetrieve', 'uuid', uuid)
            const localVarPath = `/experiments/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Experiments are collections of Cycler Tests which are grouped together for analysis.
         * @param {string} uuid A UUID string identifying this experiment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        experimentsWithValidationRetrieve: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('experimentsWithValidationRetrieve', 'uuid', uuid)
            const localVarPath = `/experiments/{uuid}/with_validation/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExperimentsApi - functional programming interface
 * @export
 */
export const ExperimentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExperimentsApiAxiosParamCreator(configuration)
    return {
        /**
         *  Experiments are collections of Cycler Tests which are grouped together for analysis.         
         * @summary Create an Experiment
         * @param {Experiment} experiment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async experimentsCreate(experiment: Experiment, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Experiment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.experimentsCreate(experiment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Experiments are collections of Cycler Tests which are grouped together for analysis.
         * @param {string} uuid A UUID string identifying this experiment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async experimentsDestroy(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.experimentsDestroy(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Experiments are collections of Cycler Tests which are grouped together for analysis.         
         * @summary View Experiments
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async experimentsList(limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedExperimentList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.experimentsList(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Experiments are collections of Cycler Tests which are grouped together for analysis.
         * @param {string} uuid A UUID string identifying this experiment.
         * @param {PatchedExperiment} [patchedExperiment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async experimentsPartialUpdate(uuid: string, patchedExperiment?: PatchedExperiment, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Experiment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.experimentsPartialUpdate(uuid, patchedExperiment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Experiments are collections of Cycler Tests which are grouped together for analysis.         
         * @summary View an Experiment
         * @param {string} uuid A UUID string identifying this experiment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async experimentsRetrieve(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Experiment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.experimentsRetrieve(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Experiments are collections of Cycler Tests which are grouped together for analysis.
         * @param {string} uuid A UUID string identifying this experiment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async experimentsWithValidationRetrieve(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Experiment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.experimentsWithValidationRetrieve(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ExperimentsApi - factory interface
 * @export
 */
export const ExperimentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExperimentsApiFp(configuration)
    return {
        /**
         *  Experiments are collections of Cycler Tests which are grouped together for analysis.         
         * @summary Create an Experiment
         * @param {Experiment} experiment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        experimentsCreate(experiment: Experiment, options?: any): AxiosPromise<Experiment> {
            return localVarFp.experimentsCreate(experiment, options).then((request) => request(axios, basePath));
        },
        /**
         * Experiments are collections of Cycler Tests which are grouped together for analysis.
         * @param {string} uuid A UUID string identifying this experiment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        experimentsDestroy(uuid: string, options?: any): AxiosPromise<void> {
            return localVarFp.experimentsDestroy(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         *  Experiments are collections of Cycler Tests which are grouped together for analysis.         
         * @summary View Experiments
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        experimentsList(limit?: number, offset?: number, options?: any): AxiosPromise<PaginatedExperimentList> {
            return localVarFp.experimentsList(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Experiments are collections of Cycler Tests which are grouped together for analysis.
         * @param {string} uuid A UUID string identifying this experiment.
         * @param {PatchedExperiment} [patchedExperiment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        experimentsPartialUpdate(uuid: string, patchedExperiment?: PatchedExperiment, options?: any): AxiosPromise<Experiment> {
            return localVarFp.experimentsPartialUpdate(uuid, patchedExperiment, options).then((request) => request(axios, basePath));
        },
        /**
         *  Experiments are collections of Cycler Tests which are grouped together for analysis.         
         * @summary View an Experiment
         * @param {string} uuid A UUID string identifying this experiment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        experimentsRetrieve(uuid: string, options?: any): AxiosPromise<Experiment> {
            return localVarFp.experimentsRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Experiments are collections of Cycler Tests which are grouped together for analysis.
         * @param {string} uuid A UUID string identifying this experiment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        experimentsWithValidationRetrieve(uuid: string, options?: any): AxiosPromise<Experiment> {
            return localVarFp.experimentsWithValidationRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExperimentsApi - object-oriented interface
 * @export
 * @class ExperimentsApi
 * @extends {BaseAPI}
 */
export class ExperimentsApi extends BaseAPI {
    /**
     *  Experiments are collections of Cycler Tests which are grouped together for analysis.         
     * @summary Create an Experiment
     * @param {Experiment} experiment 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public experimentsCreate(experiment: Experiment, options?: AxiosRequestConfig) {
        return ExperimentsApiFp(this.configuration).experimentsCreate(experiment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Experiments are collections of Cycler Tests which are grouped together for analysis.
     * @param {string} uuid A UUID string identifying this experiment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public experimentsDestroy(uuid: string, options?: AxiosRequestConfig) {
        return ExperimentsApiFp(this.configuration).experimentsDestroy(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Experiments are collections of Cycler Tests which are grouped together for analysis.         
     * @summary View Experiments
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public experimentsList(limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return ExperimentsApiFp(this.configuration).experimentsList(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Experiments are collections of Cycler Tests which are grouped together for analysis.
     * @param {string} uuid A UUID string identifying this experiment.
     * @param {PatchedExperiment} [patchedExperiment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public experimentsPartialUpdate(uuid: string, patchedExperiment?: PatchedExperiment, options?: AxiosRequestConfig) {
        return ExperimentsApiFp(this.configuration).experimentsPartialUpdate(uuid, patchedExperiment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Experiments are collections of Cycler Tests which are grouped together for analysis.         
     * @summary View an Experiment
     * @param {string} uuid A UUID string identifying this experiment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public experimentsRetrieve(uuid: string, options?: AxiosRequestConfig) {
        return ExperimentsApiFp(this.configuration).experimentsRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Experiments are collections of Cycler Tests which are grouped together for analysis.
     * @param {string} uuid A UUID string identifying this experiment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public experimentsWithValidationRetrieve(uuid: string, options?: AxiosRequestConfig) {
        return ExperimentsApiFp(this.configuration).experimentsWithValidationRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FilesApi - axios parameter creator
 * @export
 */
export const FilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Files are files in a directory marked as a monitored Path for a Harvester.  They are reported to Galv by the harvester program. An File will have file metadata (size, modification time), and a status representing its import state. It may be linked to HarvestErrors encountered while importing the file, and/or to Datasets representing the content of imported files.  You can see all files on any Path on which you are an Administrator or User. Harvester Administrators have access to all Files on the Harvester\'s Paths.  Searchable fields: - path - state         
         * @summary View Files on a Path you can access
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesList: async (limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/files/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ObservedFiles are files that exist (or have existed) in a MonitoredPath and have been reported to Galv by the Harvester.  An ObservedFile instance will have file metadata (size, modification time), and a status representing its import state. It may be linked to HarvestErrors encountered while importing the file, and/or to Datasets representing the content of imported files.
         * @param {string} uuid A UUID string identifying this observed file.
         * @param {PatchedObservedFile} [patchedObservedFile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesPartialUpdate: async (uuid: string, patchedObservedFile?: PatchedObservedFile, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('filesPartialUpdate', 'uuid', uuid)
            const localVarPath = `/files/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedObservedFile, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  A File will usually only be imported once, provided it is created, written to, and then left alone. Files will naturally be reimported if they grow in size again. If an error was encountered while processing a file, or you have other reasons for wishing to repeat the import process, you can use this endpoint to force the harvester program to rerun the import process when it next scans the file.  *Note*: This request may be overwritten if the file changes size before it is next scanned.         
         * @summary Force a File to be re-imported
         * @param {string} uuid A UUID string identifying this observed file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesReimportRetrieve: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('filesReimportRetrieve', 'uuid', uuid)
            const localVarPath = `/files/{uuid}/reimport/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Files are files in a directory marked as a monitored Path for a Harvester.         
         * @summary View a File
         * @param {string} uuid A UUID string identifying this observed file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesRetrieve: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('filesRetrieve', 'uuid', uuid)
            const localVarPath = `/files/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ObservedFiles are files that exist (or have existed) in a MonitoredPath and have been reported to Galv by the Harvester.  An ObservedFile instance will have file metadata (size, modification time), and a status representing its import state. It may be linked to HarvestErrors encountered while importing the file, and/or to Datasets representing the content of imported files.
         * @param {string} uuid A UUID string identifying this observed file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesWithValidationRetrieve: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('filesWithValidationRetrieve', 'uuid', uuid)
            const localVarPath = `/files/{uuid}/with_validation/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilesApi - functional programming interface
 * @export
 */
export const FilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilesApiAxiosParamCreator(configuration)
    return {
        /**
         *  Files are files in a directory marked as a monitored Path for a Harvester.  They are reported to Galv by the harvester program. An File will have file metadata (size, modification time), and a status representing its import state. It may be linked to HarvestErrors encountered while importing the file, and/or to Datasets representing the content of imported files.  You can see all files on any Path on which you are an Administrator or User. Harvester Administrators have access to all Files on the Harvester\'s Paths.  Searchable fields: - path - state         
         * @summary View Files on a Path you can access
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesList(limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedObservedFileList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesList(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ObservedFiles are files that exist (or have existed) in a MonitoredPath and have been reported to Galv by the Harvester.  An ObservedFile instance will have file metadata (size, modification time), and a status representing its import state. It may be linked to HarvestErrors encountered while importing the file, and/or to Datasets representing the content of imported files.
         * @param {string} uuid A UUID string identifying this observed file.
         * @param {PatchedObservedFile} [patchedObservedFile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesPartialUpdate(uuid: string, patchedObservedFile?: PatchedObservedFile, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObservedFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesPartialUpdate(uuid, patchedObservedFile, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  A File will usually only be imported once, provided it is created, written to, and then left alone. Files will naturally be reimported if they grow in size again. If an error was encountered while processing a file, or you have other reasons for wishing to repeat the import process, you can use this endpoint to force the harvester program to rerun the import process when it next scans the file.  *Note*: This request may be overwritten if the file changes size before it is next scanned.         
         * @summary Force a File to be re-imported
         * @param {string} uuid A UUID string identifying this observed file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesReimportRetrieve(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObservedFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesReimportRetrieve(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Files are files in a directory marked as a monitored Path for a Harvester.         
         * @summary View a File
         * @param {string} uuid A UUID string identifying this observed file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesRetrieve(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObservedFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesRetrieve(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ObservedFiles are files that exist (or have existed) in a MonitoredPath and have been reported to Galv by the Harvester.  An ObservedFile instance will have file metadata (size, modification time), and a status representing its import state. It may be linked to HarvestErrors encountered while importing the file, and/or to Datasets representing the content of imported files.
         * @param {string} uuid A UUID string identifying this observed file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesWithValidationRetrieve(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObservedFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesWithValidationRetrieve(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FilesApi - factory interface
 * @export
 */
export const FilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilesApiFp(configuration)
    return {
        /**
         *  Files are files in a directory marked as a monitored Path for a Harvester.  They are reported to Galv by the harvester program. An File will have file metadata (size, modification time), and a status representing its import state. It may be linked to HarvestErrors encountered while importing the file, and/or to Datasets representing the content of imported files.  You can see all files on any Path on which you are an Administrator or User. Harvester Administrators have access to all Files on the Harvester\'s Paths.  Searchable fields: - path - state         
         * @summary View Files on a Path you can access
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesList(limit?: number, offset?: number, options?: any): AxiosPromise<PaginatedObservedFileList> {
            return localVarFp.filesList(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * ObservedFiles are files that exist (or have existed) in a MonitoredPath and have been reported to Galv by the Harvester.  An ObservedFile instance will have file metadata (size, modification time), and a status representing its import state. It may be linked to HarvestErrors encountered while importing the file, and/or to Datasets representing the content of imported files.
         * @param {string} uuid A UUID string identifying this observed file.
         * @param {PatchedObservedFile} [patchedObservedFile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesPartialUpdate(uuid: string, patchedObservedFile?: PatchedObservedFile, options?: any): AxiosPromise<ObservedFile> {
            return localVarFp.filesPartialUpdate(uuid, patchedObservedFile, options).then((request) => request(axios, basePath));
        },
        /**
         *  A File will usually only be imported once, provided it is created, written to, and then left alone. Files will naturally be reimported if they grow in size again. If an error was encountered while processing a file, or you have other reasons for wishing to repeat the import process, you can use this endpoint to force the harvester program to rerun the import process when it next scans the file.  *Note*: This request may be overwritten if the file changes size before it is next scanned.         
         * @summary Force a File to be re-imported
         * @param {string} uuid A UUID string identifying this observed file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesReimportRetrieve(uuid: string, options?: any): AxiosPromise<ObservedFile> {
            return localVarFp.filesReimportRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         *  Files are files in a directory marked as a monitored Path for a Harvester.         
         * @summary View a File
         * @param {string} uuid A UUID string identifying this observed file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesRetrieve(uuid: string, options?: any): AxiosPromise<ObservedFile> {
            return localVarFp.filesRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * ObservedFiles are files that exist (or have existed) in a MonitoredPath and have been reported to Galv by the Harvester.  An ObservedFile instance will have file metadata (size, modification time), and a status representing its import state. It may be linked to HarvestErrors encountered while importing the file, and/or to Datasets representing the content of imported files.
         * @param {string} uuid A UUID string identifying this observed file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesWithValidationRetrieve(uuid: string, options?: any): AxiosPromise<ObservedFile> {
            return localVarFp.filesWithValidationRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
export class FilesApi extends BaseAPI {
    /**
     *  Files are files in a directory marked as a monitored Path for a Harvester.  They are reported to Galv by the harvester program. An File will have file metadata (size, modification time), and a status representing its import state. It may be linked to HarvestErrors encountered while importing the file, and/or to Datasets representing the content of imported files.  You can see all files on any Path on which you are an Administrator or User. Harvester Administrators have access to all Files on the Harvester\'s Paths.  Searchable fields: - path - state         
     * @summary View Files on a Path you can access
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public filesList(limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).filesList(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ObservedFiles are files that exist (or have existed) in a MonitoredPath and have been reported to Galv by the Harvester.  An ObservedFile instance will have file metadata (size, modification time), and a status representing its import state. It may be linked to HarvestErrors encountered while importing the file, and/or to Datasets representing the content of imported files.
     * @param {string} uuid A UUID string identifying this observed file.
     * @param {PatchedObservedFile} [patchedObservedFile] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public filesPartialUpdate(uuid: string, patchedObservedFile?: PatchedObservedFile, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).filesPartialUpdate(uuid, patchedObservedFile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  A File will usually only be imported once, provided it is created, written to, and then left alone. Files will naturally be reimported if they grow in size again. If an error was encountered while processing a file, or you have other reasons for wishing to repeat the import process, you can use this endpoint to force the harvester program to rerun the import process when it next scans the file.  *Note*: This request may be overwritten if the file changes size before it is next scanned.         
     * @summary Force a File to be re-imported
     * @param {string} uuid A UUID string identifying this observed file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public filesReimportRetrieve(uuid: string, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).filesReimportRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Files are files in a directory marked as a monitored Path for a Harvester.         
     * @summary View a File
     * @param {string} uuid A UUID string identifying this observed file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public filesRetrieve(uuid: string, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).filesRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ObservedFiles are files that exist (or have existed) in a MonitoredPath and have been reported to Galv by the Harvester.  An ObservedFile instance will have file metadata (size, modification time), and a status representing its import state. It may be linked to HarvestErrors encountered while importing the file, and/or to Datasets representing the content of imported files.
     * @param {string} uuid A UUID string identifying this observed file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public filesWithValidationRetrieve(uuid: string, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).filesWithValidationRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GroupsApi - axios parameter creator
 * @export
 */
export const GroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Groups are Django Group instances custom-serialized for convenience.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsList: async (limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Groups are Django Group instances custom-serialized for convenience.
         * @param {number} id A unique integer value identifying this group proxy.
         * @param {PatchedGroup} [patchedGroup] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsPartialUpdate: async (id: number, patchedGroup?: PatchedGroup, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('groupsPartialUpdate', 'id', id)
            const localVarPath = `/groups/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedGroup, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Groups are Django Group instances custom-serialized for convenience.
         * @param {number} id A unique integer value identifying this group proxy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('groupsRetrieve', 'id', id)
            const localVarPath = `/groups/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupsApi - functional programming interface
 * @export
 */
export const GroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * Groups are Django Group instances custom-serialized for convenience.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsList(limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedGroupList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsList(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Groups are Django Group instances custom-serialized for convenience.
         * @param {number} id A unique integer value identifying this group proxy.
         * @param {PatchedGroup} [patchedGroup] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsPartialUpdate(id: number, patchedGroup?: PatchedGroup, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsPartialUpdate(id, patchedGroup, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Groups are Django Group instances custom-serialized for convenience.
         * @param {number} id A unique integer value identifying this group proxy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GroupsApi - factory interface
 * @export
 */
export const GroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupsApiFp(configuration)
    return {
        /**
         * Groups are Django Group instances custom-serialized for convenience.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsList(limit?: number, offset?: number, options?: any): AxiosPromise<PaginatedGroupList> {
            return localVarFp.groupsList(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Groups are Django Group instances custom-serialized for convenience.
         * @param {number} id A unique integer value identifying this group proxy.
         * @param {PatchedGroup} [patchedGroup] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsPartialUpdate(id: number, patchedGroup?: PatchedGroup, options?: any): AxiosPromise<Group> {
            return localVarFp.groupsPartialUpdate(id, patchedGroup, options).then((request) => request(axios, basePath));
        },
        /**
         * Groups are Django Group instances custom-serialized for convenience.
         * @param {number} id A unique integer value identifying this group proxy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsRetrieve(id: number, options?: any): AxiosPromise<Group> {
            return localVarFp.groupsRetrieve(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupsApi - object-oriented interface
 * @export
 * @class GroupsApi
 * @extends {BaseAPI}
 */
export class GroupsApi extends BaseAPI {
    /**
     * Groups are Django Group instances custom-serialized for convenience.
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsList(limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupsList(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Groups are Django Group instances custom-serialized for convenience.
     * @param {number} id A unique integer value identifying this group proxy.
     * @param {PatchedGroup} [patchedGroup] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsPartialUpdate(id: number, patchedGroup?: PatchedGroup, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupsPartialUpdate(id, patchedGroup, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Groups are Django Group instances custom-serialized for convenience.
     * @param {number} id A unique integer value identifying this group proxy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsRetrieve(id: number, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HarvestErrorsApi - axios parameter creator
 * @export
 */
export const HarvestErrorsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  View the Errors encountered by Harvesters to which you have access.  Harvesters report errors when they encounter them, either in crawling or in processing files. If a File or Dataset is not appearing on a Path where you think it should be, this is the first place to check.  Searchable fields: - error         
         * @summary View Errors encountered while Harvesting
         * @param {string} [file] 
         * @param {string} [harvester] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        harvestErrorsList: async (file?: string, harvester?: string, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/harvest_errors/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (file !== undefined) {
                localVarQueryParameter['file'] = file;
            }

            if (harvester !== undefined) {
                localVarQueryParameter['harvester'] = harvester;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  View an Error reported by a Harvester.         
         * @summary View Error details
         * @param {number} id A unique integer value identifying this harvest error.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        harvestErrorsRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('harvestErrorsRetrieve', 'id', id)
            const localVarPath = `/harvest_errors/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HarvestErrorsApi - functional programming interface
 * @export
 */
export const HarvestErrorsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HarvestErrorsApiAxiosParamCreator(configuration)
    return {
        /**
         *  View the Errors encountered by Harvesters to which you have access.  Harvesters report errors when they encounter them, either in crawling or in processing files. If a File or Dataset is not appearing on a Path where you think it should be, this is the first place to check.  Searchable fields: - error         
         * @summary View Errors encountered while Harvesting
         * @param {string} [file] 
         * @param {string} [harvester] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async harvestErrorsList(file?: string, harvester?: string, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedHarvestErrorList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.harvestErrorsList(file, harvester, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  View an Error reported by a Harvester.         
         * @summary View Error details
         * @param {number} id A unique integer value identifying this harvest error.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async harvestErrorsRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HarvestError>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.harvestErrorsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HarvestErrorsApi - factory interface
 * @export
 */
export const HarvestErrorsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HarvestErrorsApiFp(configuration)
    return {
        /**
         *  View the Errors encountered by Harvesters to which you have access.  Harvesters report errors when they encounter them, either in crawling or in processing files. If a File or Dataset is not appearing on a Path where you think it should be, this is the first place to check.  Searchable fields: - error         
         * @summary View Errors encountered while Harvesting
         * @param {string} [file] 
         * @param {string} [harvester] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        harvestErrorsList(file?: string, harvester?: string, limit?: number, offset?: number, options?: any): AxiosPromise<PaginatedHarvestErrorList> {
            return localVarFp.harvestErrorsList(file, harvester, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         *  View an Error reported by a Harvester.         
         * @summary View Error details
         * @param {number} id A unique integer value identifying this harvest error.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        harvestErrorsRetrieve(id: number, options?: any): AxiosPromise<HarvestError> {
            return localVarFp.harvestErrorsRetrieve(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HarvestErrorsApi - object-oriented interface
 * @export
 * @class HarvestErrorsApi
 * @extends {BaseAPI}
 */
export class HarvestErrorsApi extends BaseAPI {
    /**
     *  View the Errors encountered by Harvesters to which you have access.  Harvesters report errors when they encounter them, either in crawling or in processing files. If a File or Dataset is not appearing on a Path where you think it should be, this is the first place to check.  Searchable fields: - error         
     * @summary View Errors encountered while Harvesting
     * @param {string} [file] 
     * @param {string} [harvester] 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HarvestErrorsApi
     */
    public harvestErrorsList(file?: string, harvester?: string, limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return HarvestErrorsApiFp(this.configuration).harvestErrorsList(file, harvester, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  View an Error reported by a Harvester.         
     * @summary View Error details
     * @param {number} id A unique integer value identifying this harvest error.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HarvestErrorsApi
     */
    public harvestErrorsRetrieve(id: number, options?: AxiosRequestConfig) {
        return HarvestErrorsApiFp(this.configuration).harvestErrorsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HarvestersApi - axios parameter creator
 * @export
 */
export const HarvestersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Harvesters monitor a set of MonitoredPaths and send reports about ObservedFiles within those paths. You can view all Harvesters for any Labs you are a member of.  Searchable fields: - name         
         * @summary View all Harvesters
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        harvestersList: async (limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/harvesters/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Some Harvester details can be updated after the Harvester is created. Those details are updated using this endpoint.  Only Harvester Administrators are authorised to make these changes.         
         * @summary Update Harvester details
         * @param {string} uuid A UUID string identifying this harvester.
         * @param {PatchedHarvester} [patchedHarvester] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        harvestersPartialUpdate: async (uuid: string, patchedHarvester?: PatchedHarvester, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('harvestersPartialUpdate', 'uuid', uuid)
            const localVarPath = `/harvesters/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedHarvester, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Harvesters monitor a set of MonitoredPaths and send reports about ObservedFiles within those paths.         
         * @summary View a single Harvester
         * @param {string} uuid A UUID string identifying this harvester.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        harvestersRetrieve: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('harvestersRetrieve', 'uuid', uuid)
            const localVarPath = `/harvesters/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Harvesters monitor a set of MonitoredPaths and send reports about ObservedFiles within those paths. A Harvester belongs to a Lab and its Monitored Paths are used by Teams within the Lab.  When Harvesters communicate with the API they do so using special Harvester API Keys. These provide access to the report and configuration endpoints.  Harvesters are created by a separate software package available within Galv.
         * @param {string} uuid A UUID string identifying this harvester.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        harvestersWithValidationRetrieve: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('harvestersWithValidationRetrieve', 'uuid', uuid)
            const localVarPath = `/harvesters/{uuid}/with_validation/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HarvestersApi - functional programming interface
 * @export
 */
export const HarvestersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HarvestersApiAxiosParamCreator(configuration)
    return {
        /**
         *  Harvesters monitor a set of MonitoredPaths and send reports about ObservedFiles within those paths. You can view all Harvesters for any Labs you are a member of.  Searchable fields: - name         
         * @summary View all Harvesters
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async harvestersList(limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedHarvesterList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.harvestersList(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Some Harvester details can be updated after the Harvester is created. Those details are updated using this endpoint.  Only Harvester Administrators are authorised to make these changes.         
         * @summary Update Harvester details
         * @param {string} uuid A UUID string identifying this harvester.
         * @param {PatchedHarvester} [patchedHarvester] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async harvestersPartialUpdate(uuid: string, patchedHarvester?: PatchedHarvester, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Harvester>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.harvestersPartialUpdate(uuid, patchedHarvester, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Harvesters monitor a set of MonitoredPaths and send reports about ObservedFiles within those paths.         
         * @summary View a single Harvester
         * @param {string} uuid A UUID string identifying this harvester.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async harvestersRetrieve(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Harvester>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.harvestersRetrieve(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Harvesters monitor a set of MonitoredPaths and send reports about ObservedFiles within those paths. A Harvester belongs to a Lab and its Monitored Paths are used by Teams within the Lab.  When Harvesters communicate with the API they do so using special Harvester API Keys. These provide access to the report and configuration endpoints.  Harvesters are created by a separate software package available within Galv.
         * @param {string} uuid A UUID string identifying this harvester.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async harvestersWithValidationRetrieve(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Harvester>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.harvestersWithValidationRetrieve(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HarvestersApi - factory interface
 * @export
 */
export const HarvestersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HarvestersApiFp(configuration)
    return {
        /**
         *  Harvesters monitor a set of MonitoredPaths and send reports about ObservedFiles within those paths. You can view all Harvesters for any Labs you are a member of.  Searchable fields: - name         
         * @summary View all Harvesters
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        harvestersList(limit?: number, offset?: number, options?: any): AxiosPromise<PaginatedHarvesterList> {
            return localVarFp.harvestersList(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         *  Some Harvester details can be updated after the Harvester is created. Those details are updated using this endpoint.  Only Harvester Administrators are authorised to make these changes.         
         * @summary Update Harvester details
         * @param {string} uuid A UUID string identifying this harvester.
         * @param {PatchedHarvester} [patchedHarvester] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        harvestersPartialUpdate(uuid: string, patchedHarvester?: PatchedHarvester, options?: any): AxiosPromise<Harvester> {
            return localVarFp.harvestersPartialUpdate(uuid, patchedHarvester, options).then((request) => request(axios, basePath));
        },
        /**
         *  Harvesters monitor a set of MonitoredPaths and send reports about ObservedFiles within those paths.         
         * @summary View a single Harvester
         * @param {string} uuid A UUID string identifying this harvester.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        harvestersRetrieve(uuid: string, options?: any): AxiosPromise<Harvester> {
            return localVarFp.harvestersRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Harvesters monitor a set of MonitoredPaths and send reports about ObservedFiles within those paths. A Harvester belongs to a Lab and its Monitored Paths are used by Teams within the Lab.  When Harvesters communicate with the API they do so using special Harvester API Keys. These provide access to the report and configuration endpoints.  Harvesters are created by a separate software package available within Galv.
         * @param {string} uuid A UUID string identifying this harvester.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        harvestersWithValidationRetrieve(uuid: string, options?: any): AxiosPromise<Harvester> {
            return localVarFp.harvestersWithValidationRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HarvestersApi - object-oriented interface
 * @export
 * @class HarvestersApi
 * @extends {BaseAPI}
 */
export class HarvestersApi extends BaseAPI {
    /**
     *  Harvesters monitor a set of MonitoredPaths and send reports about ObservedFiles within those paths. You can view all Harvesters for any Labs you are a member of.  Searchable fields: - name         
     * @summary View all Harvesters
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HarvestersApi
     */
    public harvestersList(limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return HarvestersApiFp(this.configuration).harvestersList(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Some Harvester details can be updated after the Harvester is created. Those details are updated using this endpoint.  Only Harvester Administrators are authorised to make these changes.         
     * @summary Update Harvester details
     * @param {string} uuid A UUID string identifying this harvester.
     * @param {PatchedHarvester} [patchedHarvester] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HarvestersApi
     */
    public harvestersPartialUpdate(uuid: string, patchedHarvester?: PatchedHarvester, options?: AxiosRequestConfig) {
        return HarvestersApiFp(this.configuration).harvestersPartialUpdate(uuid, patchedHarvester, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Harvesters monitor a set of MonitoredPaths and send reports about ObservedFiles within those paths.         
     * @summary View a single Harvester
     * @param {string} uuid A UUID string identifying this harvester.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HarvestersApi
     */
    public harvestersRetrieve(uuid: string, options?: AxiosRequestConfig) {
        return HarvestersApiFp(this.configuration).harvestersRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Harvesters monitor a set of MonitoredPaths and send reports about ObservedFiles within those paths. A Harvester belongs to a Lab and its Monitored Paths are used by Teams within the Lab.  When Harvesters communicate with the API they do so using special Harvester API Keys. These provide access to the report and configuration endpoints.  Harvesters are created by a separate software package available within Galv.
     * @param {string} uuid A UUID string identifying this harvester.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HarvestersApi
     */
    public harvestersWithValidationRetrieve(uuid: string, options?: AxiosRequestConfig) {
        return HarvestersApiFp(this.configuration).harvestersWithValidationRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LabsApi - axios parameter creator
 * @export
 */
export const LabsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Labs are collections of Teams that provide for wider-scale access management and administration. 
         * @summary Create a new Lab
         * @param {Lab} lab 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        labsCreate: async (lab: Lab, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lab' is not null or undefined
            assertParamExists('labsCreate', 'lab', lab)
            const localVarPath = `/labs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(lab, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this lab.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        labsDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('labsDestroy', 'id', id)
            const localVarPath = `/labs/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Labs are collections of Teams that provide for wider-scale access management and administration. 
         * @summary View all Labs
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        labsList: async (limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/labs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Labs are collections of Teams that provide for wider-scale access management and administration. 
         * @summary Update a Lab
         * @param {number} id A unique integer value identifying this lab.
         * @param {PatchedLab} [patchedLab] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        labsPartialUpdate: async (id: number, patchedLab?: PatchedLab, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('labsPartialUpdate', 'id', id)
            const localVarPath = `/labs/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedLab, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Labs are collections of Teams that provide for wider-scale access management and administration. 
         * @summary View a single Lab
         * @param {number} id A unique integer value identifying this lab.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        labsRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('labsRetrieve', 'id', id)
            const localVarPath = `/labs/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LabsApi - functional programming interface
 * @export
 */
export const LabsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LabsApiAxiosParamCreator(configuration)
    return {
        /**
         *  Labs are collections of Teams that provide for wider-scale access management and administration. 
         * @summary Create a new Lab
         * @param {Lab} lab 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async labsCreate(lab: Lab, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Lab>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.labsCreate(lab, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this lab.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async labsDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.labsDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Labs are collections of Teams that provide for wider-scale access management and administration. 
         * @summary View all Labs
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async labsList(limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedLabList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.labsList(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Labs are collections of Teams that provide for wider-scale access management and administration. 
         * @summary Update a Lab
         * @param {number} id A unique integer value identifying this lab.
         * @param {PatchedLab} [patchedLab] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async labsPartialUpdate(id: number, patchedLab?: PatchedLab, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Lab>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.labsPartialUpdate(id, patchedLab, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Labs are collections of Teams that provide for wider-scale access management and administration. 
         * @summary View a single Lab
         * @param {number} id A unique integer value identifying this lab.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async labsRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Lab>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.labsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LabsApi - factory interface
 * @export
 */
export const LabsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LabsApiFp(configuration)
    return {
        /**
         *  Labs are collections of Teams that provide for wider-scale access management and administration. 
         * @summary Create a new Lab
         * @param {Lab} lab 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        labsCreate(lab: Lab, options?: any): AxiosPromise<Lab> {
            return localVarFp.labsCreate(lab, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this lab.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        labsDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.labsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Labs are collections of Teams that provide for wider-scale access management and administration. 
         * @summary View all Labs
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        labsList(limit?: number, offset?: number, options?: any): AxiosPromise<PaginatedLabList> {
            return localVarFp.labsList(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         *  Labs are collections of Teams that provide for wider-scale access management and administration. 
         * @summary Update a Lab
         * @param {number} id A unique integer value identifying this lab.
         * @param {PatchedLab} [patchedLab] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        labsPartialUpdate(id: number, patchedLab?: PatchedLab, options?: any): AxiosPromise<Lab> {
            return localVarFp.labsPartialUpdate(id, patchedLab, options).then((request) => request(axios, basePath));
        },
        /**
         *  Labs are collections of Teams that provide for wider-scale access management and administration. 
         * @summary View a single Lab
         * @param {number} id A unique integer value identifying this lab.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        labsRetrieve(id: number, options?: any): AxiosPromise<Lab> {
            return localVarFp.labsRetrieve(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LabsApi - object-oriented interface
 * @export
 * @class LabsApi
 * @extends {BaseAPI}
 */
export class LabsApi extends BaseAPI {
    /**
     *  Labs are collections of Teams that provide for wider-scale access management and administration. 
     * @summary Create a new Lab
     * @param {Lab} lab 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabsApi
     */
    public labsCreate(lab: Lab, options?: AxiosRequestConfig) {
        return LabsApiFp(this.configuration).labsCreate(lab, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this lab.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabsApi
     */
    public labsDestroy(id: number, options?: AxiosRequestConfig) {
        return LabsApiFp(this.configuration).labsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Labs are collections of Teams that provide for wider-scale access management and administration. 
     * @summary View all Labs
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabsApi
     */
    public labsList(limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return LabsApiFp(this.configuration).labsList(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Labs are collections of Teams that provide for wider-scale access management and administration. 
     * @summary Update a Lab
     * @param {number} id A unique integer value identifying this lab.
     * @param {PatchedLab} [patchedLab] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabsApi
     */
    public labsPartialUpdate(id: number, patchedLab?: PatchedLab, options?: AxiosRequestConfig) {
        return LabsApiFp(this.configuration).labsPartialUpdate(id, patchedLab, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Labs are collections of Teams that provide for wider-scale access management and administration. 
     * @summary View a single Lab
     * @param {number} id A unique integer value identifying this lab.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabsApi
     */
    public labsRetrieve(id: number, options?: AxiosRequestConfig) {
        return LabsApiFp(this.configuration).labsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LoginApi - axios parameter creator
 * @export
 */
export const LoginApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Sign in with a username and password to obtain an API Token. The token will allow you access to appropriate parts of the API in subsequent requests.  Subsequent requests should include the Authorization header with the content `Bearer token` where token is the token you received in exchange for your credentials here.     
         * @summary Log in to retrieve an API Token for use elsewhere in the API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginCreate: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/login/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LoginApi - functional programming interface
 * @export
 */
export const LoginApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LoginApiAxiosParamCreator(configuration)
    return {
        /**
         *  Sign in with a username and password to obtain an API Token. The token will allow you access to appropriate parts of the API in subsequent requests.  Subsequent requests should include the Authorization header with the content `Bearer token` where token is the token you received in exchange for your credentials here.     
         * @summary Log in to retrieve an API Token for use elsewhere in the API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginCreate(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KnoxUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginCreate(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LoginApi - factory interface
 * @export
 */
export const LoginApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LoginApiFp(configuration)
    return {
        /**
         *  Sign in with a username and password to obtain an API Token. The token will allow you access to appropriate parts of the API in subsequent requests.  Subsequent requests should include the Authorization header with the content `Bearer token` where token is the token you received in exchange for your credentials here.     
         * @summary Log in to retrieve an API Token for use elsewhere in the API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginCreate(options?: any): AxiosPromise<KnoxUser> {
            return localVarFp.loginCreate(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LoginApi - object-oriented interface
 * @export
 * @class LoginApi
 * @extends {BaseAPI}
 */
export class LoginApi extends BaseAPI {
    /**
     *  Sign in with a username and password to obtain an API Token. The token will allow you access to appropriate parts of the API in subsequent requests.  Subsequent requests should include the Authorization header with the content `Bearer token` where token is the token you received in exchange for your credentials here.     
     * @summary Log in to retrieve an API Token for use elsewhere in the API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginApi
     */
    public loginCreate(options?: AxiosRequestConfig) {
        return LoginApiFp(this.configuration).loginCreate(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MonitoredPathsApi - axios parameter creator
 * @export
 */
export const MonitoredPathsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Register a new directory on for a Harvester to crawl. Files in that directory will be scanned periodically by the Harvester, becoming ObservedFiles once they are reported to Galv by the Harvester.         
         * @summary Create a new Path
         * @param {MonitoredPath} monitoredPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        monitoredPathsCreate: async (monitoredPath: MonitoredPath, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'monitoredPath' is not null or undefined
            assertParamExists('monitoredPathsCreate', 'monitoredPath', monitoredPath)
            const localVarPath = `/monitored_paths/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(monitoredPath, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Delete a directory from a Harvester\'s list of directories to crawl. Files in that directory will no longer be scanned periodically by the Harvester, and will no longer become ObservedFiles once they are reported to Galv by the Harvester.         
         * @summary Delete a Path
         * @param {string} uuid A UUID string identifying this monitored path.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        monitoredPathsDestroy: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('monitoredPathsDestroy', 'uuid', uuid)
            const localVarPath = `/monitored_paths/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  A Path refers to a directory accessible by a Harvester in which data files will reside. Those files will be scanned periodically by the Harvester, becoming ObservedFiles once they are reported to Galv by the Harvester.  Paths can be created or updated by a Harvester\'s admins and users, as well as any users who have been given explicit permissions to edit the MonitoredPath.  Searchable fields: - path         
         * @summary View Paths to which you have access
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        monitoredPathsList: async (limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/monitored_paths/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Alter the path to the monitored directory, or the time for which files need to be stable before being imported.         
         * @summary Update a Path
         * @param {string} uuid A UUID string identifying this monitored path.
         * @param {PatchedMonitoredPath} [patchedMonitoredPath] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        monitoredPathsPartialUpdate: async (uuid: string, patchedMonitoredPath?: PatchedMonitoredPath, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('monitoredPathsPartialUpdate', 'uuid', uuid)
            const localVarPath = `/monitored_paths/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedMonitoredPath, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  A Path refers to a directory accessible by a Harvester in which data files will reside. Those files will be scanned periodically by the Harvester, becoming ObservedFiles once they are reported to Galv by the Harvester.         
         * @summary View the details of a Path
         * @param {string} uuid A UUID string identifying this monitored path.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        monitoredPathsRetrieve: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('monitoredPathsRetrieve', 'uuid', uuid)
            const localVarPath = `/monitored_paths/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A MonitoredPath refers to a directory accessible by a Harvester in which data files will reside. Those files will be scanned periodically by the Harvester, becoming ObservedFiles once they are reported to Galv by the Harvester.  MonitoredPaths can be created or updated by a Harvester\'s admins and users, as well as any users who have been given explicit permissions to edit the MonitoredPath.
         * @param {string} uuid A UUID string identifying this monitored path.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        monitoredPathsWithValidationRetrieve: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('monitoredPathsWithValidationRetrieve', 'uuid', uuid)
            const localVarPath = `/monitored_paths/{uuid}/with_validation/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MonitoredPathsApi - functional programming interface
 * @export
 */
export const MonitoredPathsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MonitoredPathsApiAxiosParamCreator(configuration)
    return {
        /**
         *  Register a new directory on for a Harvester to crawl. Files in that directory will be scanned periodically by the Harvester, becoming ObservedFiles once they are reported to Galv by the Harvester.         
         * @summary Create a new Path
         * @param {MonitoredPath} monitoredPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async monitoredPathsCreate(monitoredPath: MonitoredPath, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MonitoredPath>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.monitoredPathsCreate(monitoredPath, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Delete a directory from a Harvester\'s list of directories to crawl. Files in that directory will no longer be scanned periodically by the Harvester, and will no longer become ObservedFiles once they are reported to Galv by the Harvester.         
         * @summary Delete a Path
         * @param {string} uuid A UUID string identifying this monitored path.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async monitoredPathsDestroy(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.monitoredPathsDestroy(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  A Path refers to a directory accessible by a Harvester in which data files will reside. Those files will be scanned periodically by the Harvester, becoming ObservedFiles once they are reported to Galv by the Harvester.  Paths can be created or updated by a Harvester\'s admins and users, as well as any users who have been given explicit permissions to edit the MonitoredPath.  Searchable fields: - path         
         * @summary View Paths to which you have access
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async monitoredPathsList(limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedMonitoredPathList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.monitoredPathsList(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Alter the path to the monitored directory, or the time for which files need to be stable before being imported.         
         * @summary Update a Path
         * @param {string} uuid A UUID string identifying this monitored path.
         * @param {PatchedMonitoredPath} [patchedMonitoredPath] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async monitoredPathsPartialUpdate(uuid: string, patchedMonitoredPath?: PatchedMonitoredPath, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MonitoredPath>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.monitoredPathsPartialUpdate(uuid, patchedMonitoredPath, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  A Path refers to a directory accessible by a Harvester in which data files will reside. Those files will be scanned periodically by the Harvester, becoming ObservedFiles once they are reported to Galv by the Harvester.         
         * @summary View the details of a Path
         * @param {string} uuid A UUID string identifying this monitored path.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async monitoredPathsRetrieve(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MonitoredPath>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.monitoredPathsRetrieve(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A MonitoredPath refers to a directory accessible by a Harvester in which data files will reside. Those files will be scanned periodically by the Harvester, becoming ObservedFiles once they are reported to Galv by the Harvester.  MonitoredPaths can be created or updated by a Harvester\'s admins and users, as well as any users who have been given explicit permissions to edit the MonitoredPath.
         * @param {string} uuid A UUID string identifying this monitored path.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async monitoredPathsWithValidationRetrieve(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MonitoredPath>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.monitoredPathsWithValidationRetrieve(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MonitoredPathsApi - factory interface
 * @export
 */
export const MonitoredPathsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MonitoredPathsApiFp(configuration)
    return {
        /**
         *  Register a new directory on for a Harvester to crawl. Files in that directory will be scanned periodically by the Harvester, becoming ObservedFiles once they are reported to Galv by the Harvester.         
         * @summary Create a new Path
         * @param {MonitoredPath} monitoredPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        monitoredPathsCreate(monitoredPath: MonitoredPath, options?: any): AxiosPromise<MonitoredPath> {
            return localVarFp.monitoredPathsCreate(monitoredPath, options).then((request) => request(axios, basePath));
        },
        /**
         *  Delete a directory from a Harvester\'s list of directories to crawl. Files in that directory will no longer be scanned periodically by the Harvester, and will no longer become ObservedFiles once they are reported to Galv by the Harvester.         
         * @summary Delete a Path
         * @param {string} uuid A UUID string identifying this monitored path.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        monitoredPathsDestroy(uuid: string, options?: any): AxiosPromise<void> {
            return localVarFp.monitoredPathsDestroy(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         *  A Path refers to a directory accessible by a Harvester in which data files will reside. Those files will be scanned periodically by the Harvester, becoming ObservedFiles once they are reported to Galv by the Harvester.  Paths can be created or updated by a Harvester\'s admins and users, as well as any users who have been given explicit permissions to edit the MonitoredPath.  Searchable fields: - path         
         * @summary View Paths to which you have access
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        monitoredPathsList(limit?: number, offset?: number, options?: any): AxiosPromise<PaginatedMonitoredPathList> {
            return localVarFp.monitoredPathsList(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         *  Alter the path to the monitored directory, or the time for which files need to be stable before being imported.         
         * @summary Update a Path
         * @param {string} uuid A UUID string identifying this monitored path.
         * @param {PatchedMonitoredPath} [patchedMonitoredPath] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        monitoredPathsPartialUpdate(uuid: string, patchedMonitoredPath?: PatchedMonitoredPath, options?: any): AxiosPromise<MonitoredPath> {
            return localVarFp.monitoredPathsPartialUpdate(uuid, patchedMonitoredPath, options).then((request) => request(axios, basePath));
        },
        /**
         *  A Path refers to a directory accessible by a Harvester in which data files will reside. Those files will be scanned periodically by the Harvester, becoming ObservedFiles once they are reported to Galv by the Harvester.         
         * @summary View the details of a Path
         * @param {string} uuid A UUID string identifying this monitored path.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        monitoredPathsRetrieve(uuid: string, options?: any): AxiosPromise<MonitoredPath> {
            return localVarFp.monitoredPathsRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * A MonitoredPath refers to a directory accessible by a Harvester in which data files will reside. Those files will be scanned periodically by the Harvester, becoming ObservedFiles once they are reported to Galv by the Harvester.  MonitoredPaths can be created or updated by a Harvester\'s admins and users, as well as any users who have been given explicit permissions to edit the MonitoredPath.
         * @param {string} uuid A UUID string identifying this monitored path.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        monitoredPathsWithValidationRetrieve(uuid: string, options?: any): AxiosPromise<MonitoredPath> {
            return localVarFp.monitoredPathsWithValidationRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MonitoredPathsApi - object-oriented interface
 * @export
 * @class MonitoredPathsApi
 * @extends {BaseAPI}
 */
export class MonitoredPathsApi extends BaseAPI {
    /**
     *  Register a new directory on for a Harvester to crawl. Files in that directory will be scanned periodically by the Harvester, becoming ObservedFiles once they are reported to Galv by the Harvester.         
     * @summary Create a new Path
     * @param {MonitoredPath} monitoredPath 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MonitoredPathsApi
     */
    public monitoredPathsCreate(monitoredPath: MonitoredPath, options?: AxiosRequestConfig) {
        return MonitoredPathsApiFp(this.configuration).monitoredPathsCreate(monitoredPath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Delete a directory from a Harvester\'s list of directories to crawl. Files in that directory will no longer be scanned periodically by the Harvester, and will no longer become ObservedFiles once they are reported to Galv by the Harvester.         
     * @summary Delete a Path
     * @param {string} uuid A UUID string identifying this monitored path.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MonitoredPathsApi
     */
    public monitoredPathsDestroy(uuid: string, options?: AxiosRequestConfig) {
        return MonitoredPathsApiFp(this.configuration).monitoredPathsDestroy(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  A Path refers to a directory accessible by a Harvester in which data files will reside. Those files will be scanned periodically by the Harvester, becoming ObservedFiles once they are reported to Galv by the Harvester.  Paths can be created or updated by a Harvester\'s admins and users, as well as any users who have been given explicit permissions to edit the MonitoredPath.  Searchable fields: - path         
     * @summary View Paths to which you have access
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MonitoredPathsApi
     */
    public monitoredPathsList(limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return MonitoredPathsApiFp(this.configuration).monitoredPathsList(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Alter the path to the monitored directory, or the time for which files need to be stable before being imported.         
     * @summary Update a Path
     * @param {string} uuid A UUID string identifying this monitored path.
     * @param {PatchedMonitoredPath} [patchedMonitoredPath] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MonitoredPathsApi
     */
    public monitoredPathsPartialUpdate(uuid: string, patchedMonitoredPath?: PatchedMonitoredPath, options?: AxiosRequestConfig) {
        return MonitoredPathsApiFp(this.configuration).monitoredPathsPartialUpdate(uuid, patchedMonitoredPath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  A Path refers to a directory accessible by a Harvester in which data files will reside. Those files will be scanned periodically by the Harvester, becoming ObservedFiles once they are reported to Galv by the Harvester.         
     * @summary View the details of a Path
     * @param {string} uuid A UUID string identifying this monitored path.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MonitoredPathsApi
     */
    public monitoredPathsRetrieve(uuid: string, options?: AxiosRequestConfig) {
        return MonitoredPathsApiFp(this.configuration).monitoredPathsRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A MonitoredPath refers to a directory accessible by a Harvester in which data files will reside. Those files will be scanned periodically by the Harvester, becoming ObservedFiles once they are reported to Galv by the Harvester.  MonitoredPaths can be created or updated by a Harvester\'s admins and users, as well as any users who have been given explicit permissions to edit the MonitoredPath.
     * @param {string} uuid A UUID string identifying this monitored path.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MonitoredPathsApi
     */
    public monitoredPathsWithValidationRetrieve(uuid: string, options?: AxiosRequestConfig) {
        return MonitoredPathsApiFp(this.configuration).monitoredPathsWithValidationRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ScheduleFamiliesApi - axios parameter creator
 * @export
 */
export const ScheduleFamiliesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Schedule Families group together the general properties of a type of Schedule. Each Schedule is associated with a Schedule Family.         
         * @summary Create a Schedule Family
         * @param {ScheduleFamily} scheduleFamily 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleFamiliesCreate: async (scheduleFamily: ScheduleFamily, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleFamily' is not null or undefined
            assertParamExists('scheduleFamiliesCreate', 'scheduleFamily', scheduleFamily)
            const localVarPath = `/schedule_families/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scheduleFamily, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Schedule Families that do not have a Schedule associated with them may be deleted. Schedule Families that _do_ have Schedule associated with them are locked, to prevent accidental updating.         
         * @summary Delete a Schedule Family
         * @param {string} uuid A UUID string identifying this schedule family.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleFamiliesDestroy: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('scheduleFamiliesDestroy', 'uuid', uuid)
            const localVarPath = `/schedule_families/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Equipment Families group together the general properties of a type of Equipment. Each Equipment is associated with an Equipment Family.  Searchable fields: - type - manufacturer - form_factor         
         * @summary View Equipment Families
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleFamiliesList: async (limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/schedule_families/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Schedule Families that do not have a Schedule associated with them may be edited. Schedule Families that _do_ have Schedule associated with them are locked, to prevent accidental updating.         
         * @summary Update a Schedule Family
         * @param {string} uuid A UUID string identifying this schedule family.
         * @param {PatchedScheduleFamily} [patchedScheduleFamily] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleFamiliesPartialUpdate: async (uuid: string, patchedScheduleFamily?: PatchedScheduleFamily, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('scheduleFamiliesPartialUpdate', 'uuid', uuid)
            const localVarPath = `/schedule_families/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedScheduleFamily, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Schedule Families group together the general properties of a type of Schedule. Each Schedule is associated with a Schedule Family.         
         * @summary View a Schedule Family
         * @param {string} uuid A UUID string identifying this schedule family.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleFamiliesRetrieve: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('scheduleFamiliesRetrieve', 'uuid', uuid)
            const localVarPath = `/schedule_families/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Schedules can be attached to Cycler Tests and used to view Cycler Tests which have used similar equipment.
         * @param {string} uuid A UUID string identifying this schedule family.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleFamiliesWithValidationRetrieve: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('scheduleFamiliesWithValidationRetrieve', 'uuid', uuid)
            const localVarPath = `/schedule_families/{uuid}/with_validation/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScheduleFamiliesApi - functional programming interface
 * @export
 */
export const ScheduleFamiliesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ScheduleFamiliesApiAxiosParamCreator(configuration)
    return {
        /**
         *  Schedule Families group together the general properties of a type of Schedule. Each Schedule is associated with a Schedule Family.         
         * @summary Create a Schedule Family
         * @param {ScheduleFamily} scheduleFamily 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scheduleFamiliesCreate(scheduleFamily: ScheduleFamily, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduleFamily>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scheduleFamiliesCreate(scheduleFamily, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Schedule Families that do not have a Schedule associated with them may be deleted. Schedule Families that _do_ have Schedule associated with them are locked, to prevent accidental updating.         
         * @summary Delete a Schedule Family
         * @param {string} uuid A UUID string identifying this schedule family.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scheduleFamiliesDestroy(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scheduleFamiliesDestroy(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Equipment Families group together the general properties of a type of Equipment. Each Equipment is associated with an Equipment Family.  Searchable fields: - type - manufacturer - form_factor         
         * @summary View Equipment Families
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scheduleFamiliesList(limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedScheduleFamilyList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scheduleFamiliesList(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Schedule Families that do not have a Schedule associated with them may be edited. Schedule Families that _do_ have Schedule associated with them are locked, to prevent accidental updating.         
         * @summary Update a Schedule Family
         * @param {string} uuid A UUID string identifying this schedule family.
         * @param {PatchedScheduleFamily} [patchedScheduleFamily] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scheduleFamiliesPartialUpdate(uuid: string, patchedScheduleFamily?: PatchedScheduleFamily, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduleFamily>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scheduleFamiliesPartialUpdate(uuid, patchedScheduleFamily, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Schedule Families group together the general properties of a type of Schedule. Each Schedule is associated with a Schedule Family.         
         * @summary View a Schedule Family
         * @param {string} uuid A UUID string identifying this schedule family.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scheduleFamiliesRetrieve(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduleFamily>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scheduleFamiliesRetrieve(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Schedules can be attached to Cycler Tests and used to view Cycler Tests which have used similar equipment.
         * @param {string} uuid A UUID string identifying this schedule family.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scheduleFamiliesWithValidationRetrieve(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduleFamily>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scheduleFamiliesWithValidationRetrieve(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ScheduleFamiliesApi - factory interface
 * @export
 */
export const ScheduleFamiliesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ScheduleFamiliesApiFp(configuration)
    return {
        /**
         *  Schedule Families group together the general properties of a type of Schedule. Each Schedule is associated with a Schedule Family.         
         * @summary Create a Schedule Family
         * @param {ScheduleFamily} scheduleFamily 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleFamiliesCreate(scheduleFamily: ScheduleFamily, options?: any): AxiosPromise<ScheduleFamily> {
            return localVarFp.scheduleFamiliesCreate(scheduleFamily, options).then((request) => request(axios, basePath));
        },
        /**
         *  Schedule Families that do not have a Schedule associated with them may be deleted. Schedule Families that _do_ have Schedule associated with them are locked, to prevent accidental updating.         
         * @summary Delete a Schedule Family
         * @param {string} uuid A UUID string identifying this schedule family.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleFamiliesDestroy(uuid: string, options?: any): AxiosPromise<void> {
            return localVarFp.scheduleFamiliesDestroy(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         *  Equipment Families group together the general properties of a type of Equipment. Each Equipment is associated with an Equipment Family.  Searchable fields: - type - manufacturer - form_factor         
         * @summary View Equipment Families
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleFamiliesList(limit?: number, offset?: number, options?: any): AxiosPromise<PaginatedScheduleFamilyList> {
            return localVarFp.scheduleFamiliesList(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         *  Schedule Families that do not have a Schedule associated with them may be edited. Schedule Families that _do_ have Schedule associated with them are locked, to prevent accidental updating.         
         * @summary Update a Schedule Family
         * @param {string} uuid A UUID string identifying this schedule family.
         * @param {PatchedScheduleFamily} [patchedScheduleFamily] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleFamiliesPartialUpdate(uuid: string, patchedScheduleFamily?: PatchedScheduleFamily, options?: any): AxiosPromise<ScheduleFamily> {
            return localVarFp.scheduleFamiliesPartialUpdate(uuid, patchedScheduleFamily, options).then((request) => request(axios, basePath));
        },
        /**
         *  Schedule Families group together the general properties of a type of Schedule. Each Schedule is associated with a Schedule Family.         
         * @summary View a Schedule Family
         * @param {string} uuid A UUID string identifying this schedule family.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleFamiliesRetrieve(uuid: string, options?: any): AxiosPromise<ScheduleFamily> {
            return localVarFp.scheduleFamiliesRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Schedules can be attached to Cycler Tests and used to view Cycler Tests which have used similar equipment.
         * @param {string} uuid A UUID string identifying this schedule family.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleFamiliesWithValidationRetrieve(uuid: string, options?: any): AxiosPromise<ScheduleFamily> {
            return localVarFp.scheduleFamiliesWithValidationRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ScheduleFamiliesApi - object-oriented interface
 * @export
 * @class ScheduleFamiliesApi
 * @extends {BaseAPI}
 */
export class ScheduleFamiliesApi extends BaseAPI {
    /**
     *  Schedule Families group together the general properties of a type of Schedule. Each Schedule is associated with a Schedule Family.         
     * @summary Create a Schedule Family
     * @param {ScheduleFamily} scheduleFamily 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleFamiliesApi
     */
    public scheduleFamiliesCreate(scheduleFamily: ScheduleFamily, options?: AxiosRequestConfig) {
        return ScheduleFamiliesApiFp(this.configuration).scheduleFamiliesCreate(scheduleFamily, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Schedule Families that do not have a Schedule associated with them may be deleted. Schedule Families that _do_ have Schedule associated with them are locked, to prevent accidental updating.         
     * @summary Delete a Schedule Family
     * @param {string} uuid A UUID string identifying this schedule family.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleFamiliesApi
     */
    public scheduleFamiliesDestroy(uuid: string, options?: AxiosRequestConfig) {
        return ScheduleFamiliesApiFp(this.configuration).scheduleFamiliesDestroy(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Equipment Families group together the general properties of a type of Equipment. Each Equipment is associated with an Equipment Family.  Searchable fields: - type - manufacturer - form_factor         
     * @summary View Equipment Families
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleFamiliesApi
     */
    public scheduleFamiliesList(limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return ScheduleFamiliesApiFp(this.configuration).scheduleFamiliesList(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Schedule Families that do not have a Schedule associated with them may be edited. Schedule Families that _do_ have Schedule associated with them are locked, to prevent accidental updating.         
     * @summary Update a Schedule Family
     * @param {string} uuid A UUID string identifying this schedule family.
     * @param {PatchedScheduleFamily} [patchedScheduleFamily] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleFamiliesApi
     */
    public scheduleFamiliesPartialUpdate(uuid: string, patchedScheduleFamily?: PatchedScheduleFamily, options?: AxiosRequestConfig) {
        return ScheduleFamiliesApiFp(this.configuration).scheduleFamiliesPartialUpdate(uuid, patchedScheduleFamily, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Schedule Families group together the general properties of a type of Schedule. Each Schedule is associated with a Schedule Family.         
     * @summary View a Schedule Family
     * @param {string} uuid A UUID string identifying this schedule family.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleFamiliesApi
     */
    public scheduleFamiliesRetrieve(uuid: string, options?: AxiosRequestConfig) {
        return ScheduleFamiliesApiFp(this.configuration).scheduleFamiliesRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Schedules can be attached to Cycler Tests and used to view Cycler Tests which have used similar equipment.
     * @param {string} uuid A UUID string identifying this schedule family.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleFamiliesApi
     */
    public scheduleFamiliesWithValidationRetrieve(uuid: string, options?: AxiosRequestConfig) {
        return ScheduleFamiliesApiFp(this.configuration).scheduleFamiliesWithValidationRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ScheduleIdentifiersApi - axios parameter creator
 * @export
 */
export const ScheduleIdentifiersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Schedule Identifiers are used to describe the type of schedule used in an experiment. Examples are \"Cell Conditioning\", \"Pseudo-OCV\".
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleIdentifiersList: async (limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/schedule_identifiers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScheduleIdentifiersApi - functional programming interface
 * @export
 */
export const ScheduleIdentifiersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ScheduleIdentifiersApiAxiosParamCreator(configuration)
    return {
        /**
         * Schedule Identifiers are used to describe the type of schedule used in an experiment. Examples are \"Cell Conditioning\", \"Pseudo-OCV\".
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scheduleIdentifiersList(limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CellChemistriesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scheduleIdentifiersList(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ScheduleIdentifiersApi - factory interface
 * @export
 */
export const ScheduleIdentifiersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ScheduleIdentifiersApiFp(configuration)
    return {
        /**
         * Schedule Identifiers are used to describe the type of schedule used in an experiment. Examples are \"Cell Conditioning\", \"Pseudo-OCV\".
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleIdentifiersList(limit?: number, offset?: number, options?: any): AxiosPromise<CellChemistriesList200Response> {
            return localVarFp.scheduleIdentifiersList(limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ScheduleIdentifiersApi - object-oriented interface
 * @export
 * @class ScheduleIdentifiersApi
 * @extends {BaseAPI}
 */
export class ScheduleIdentifiersApi extends BaseAPI {
    /**
     * Schedule Identifiers are used to describe the type of schedule used in an experiment. Examples are \"Cell Conditioning\", \"Pseudo-OCV\".
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleIdentifiersApi
     */
    public scheduleIdentifiersList(limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return ScheduleIdentifiersApiFp(this.configuration).scheduleIdentifiersList(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SchedulesApi - axios parameter creator
 * @export
 */
export const SchedulesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Create a Schedule by describing its role and purpose.         
         * @summary Create Schedule
         * @param {Schedule} schedule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schedulesCreate: async (schedule: Schedule, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'schedule' is not null or undefined
            assertParamExists('schedulesCreate', 'schedule', schedule)
            const localVarPath = `/schedules/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(schedule, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Schedules that is not used in Cycler Tests may be deleted. Schedules that _is_ used in a Cycler Tests is locked to prevent accidental updating.         
         * @summary Delete Schedule
         * @param {string} uuid A UUID string identifying this schedule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schedulesDestroy: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('schedulesDestroy', 'uuid', uuid)
            const localVarPath = `/schedules/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Schedule used in experiments which generate Files and their Datasets.  Searchable fields: - identifier - description         
         * @summary View Schedule
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schedulesList: async (limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/schedules/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Schedules that is not used in Cycler Tests may be edited. Schedules that _is_ used in a Cycler Tests is locked to prevent accidental updating.         
         * @summary Update Schedule
         * @param {string} uuid A UUID string identifying this schedule.
         * @param {PatchedSchedule} [patchedSchedule] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schedulesPartialUpdate: async (uuid: string, patchedSchedule?: PatchedSchedule, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('schedulesPartialUpdate', 'uuid', uuid)
            const localVarPath = `/schedules/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedSchedule, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Schedule used in experiments which generate Files and their Datasets.         
         * @summary View specific Schedule
         * @param {string} uuid A UUID string identifying this schedule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schedulesRetrieve: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('schedulesRetrieve', 'uuid', uuid)
            const localVarPath = `/schedules/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Schedules can be attached to Cycler Tests and used to view Cycler Tests which have used similar equipment.
         * @param {string} uuid A UUID string identifying this schedule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schedulesWithValidationRetrieve: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('schedulesWithValidationRetrieve', 'uuid', uuid)
            const localVarPath = `/schedules/{uuid}/with_validation/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SchedulesApi - functional programming interface
 * @export
 */
export const SchedulesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SchedulesApiAxiosParamCreator(configuration)
    return {
        /**
         *  Create a Schedule by describing its role and purpose.         
         * @summary Create Schedule
         * @param {Schedule} schedule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schedulesCreate(schedule: Schedule, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Schedule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schedulesCreate(schedule, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Schedules that is not used in Cycler Tests may be deleted. Schedules that _is_ used in a Cycler Tests is locked to prevent accidental updating.         
         * @summary Delete Schedule
         * @param {string} uuid A UUID string identifying this schedule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schedulesDestroy(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schedulesDestroy(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Schedule used in experiments which generate Files and their Datasets.  Searchable fields: - identifier - description         
         * @summary View Schedule
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schedulesList(limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedScheduleList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schedulesList(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Schedules that is not used in Cycler Tests may be edited. Schedules that _is_ used in a Cycler Tests is locked to prevent accidental updating.         
         * @summary Update Schedule
         * @param {string} uuid A UUID string identifying this schedule.
         * @param {PatchedSchedule} [patchedSchedule] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schedulesPartialUpdate(uuid: string, patchedSchedule?: PatchedSchedule, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Schedule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schedulesPartialUpdate(uuid, patchedSchedule, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Schedule used in experiments which generate Files and their Datasets.         
         * @summary View specific Schedule
         * @param {string} uuid A UUID string identifying this schedule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schedulesRetrieve(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Schedule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schedulesRetrieve(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Schedules can be attached to Cycler Tests and used to view Cycler Tests which have used similar equipment.
         * @param {string} uuid A UUID string identifying this schedule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schedulesWithValidationRetrieve(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Schedule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schedulesWithValidationRetrieve(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SchedulesApi - factory interface
 * @export
 */
export const SchedulesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SchedulesApiFp(configuration)
    return {
        /**
         *  Create a Schedule by describing its role and purpose.         
         * @summary Create Schedule
         * @param {Schedule} schedule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schedulesCreate(schedule: Schedule, options?: any): AxiosPromise<Schedule> {
            return localVarFp.schedulesCreate(schedule, options).then((request) => request(axios, basePath));
        },
        /**
         *  Schedules that is not used in Cycler Tests may be deleted. Schedules that _is_ used in a Cycler Tests is locked to prevent accidental updating.         
         * @summary Delete Schedule
         * @param {string} uuid A UUID string identifying this schedule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schedulesDestroy(uuid: string, options?: any): AxiosPromise<void> {
            return localVarFp.schedulesDestroy(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         *  Schedule used in experiments which generate Files and their Datasets.  Searchable fields: - identifier - description         
         * @summary View Schedule
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schedulesList(limit?: number, offset?: number, options?: any): AxiosPromise<PaginatedScheduleList> {
            return localVarFp.schedulesList(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         *  Schedules that is not used in Cycler Tests may be edited. Schedules that _is_ used in a Cycler Tests is locked to prevent accidental updating.         
         * @summary Update Schedule
         * @param {string} uuid A UUID string identifying this schedule.
         * @param {PatchedSchedule} [patchedSchedule] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schedulesPartialUpdate(uuid: string, patchedSchedule?: PatchedSchedule, options?: any): AxiosPromise<Schedule> {
            return localVarFp.schedulesPartialUpdate(uuid, patchedSchedule, options).then((request) => request(axios, basePath));
        },
        /**
         *  Schedule used in experiments which generate Files and their Datasets.         
         * @summary View specific Schedule
         * @param {string} uuid A UUID string identifying this schedule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schedulesRetrieve(uuid: string, options?: any): AxiosPromise<Schedule> {
            return localVarFp.schedulesRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Schedules can be attached to Cycler Tests and used to view Cycler Tests which have used similar equipment.
         * @param {string} uuid A UUID string identifying this schedule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schedulesWithValidationRetrieve(uuid: string, options?: any): AxiosPromise<Schedule> {
            return localVarFp.schedulesWithValidationRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SchedulesApi - object-oriented interface
 * @export
 * @class SchedulesApi
 * @extends {BaseAPI}
 */
export class SchedulesApi extends BaseAPI {
    /**
     *  Create a Schedule by describing its role and purpose.         
     * @summary Create Schedule
     * @param {Schedule} schedule 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulesApi
     */
    public schedulesCreate(schedule: Schedule, options?: AxiosRequestConfig) {
        return SchedulesApiFp(this.configuration).schedulesCreate(schedule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Schedules that is not used in Cycler Tests may be deleted. Schedules that _is_ used in a Cycler Tests is locked to prevent accidental updating.         
     * @summary Delete Schedule
     * @param {string} uuid A UUID string identifying this schedule.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulesApi
     */
    public schedulesDestroy(uuid: string, options?: AxiosRequestConfig) {
        return SchedulesApiFp(this.configuration).schedulesDestroy(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Schedule used in experiments which generate Files and their Datasets.  Searchable fields: - identifier - description         
     * @summary View Schedule
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulesApi
     */
    public schedulesList(limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return SchedulesApiFp(this.configuration).schedulesList(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Schedules that is not used in Cycler Tests may be edited. Schedules that _is_ used in a Cycler Tests is locked to prevent accidental updating.         
     * @summary Update Schedule
     * @param {string} uuid A UUID string identifying this schedule.
     * @param {PatchedSchedule} [patchedSchedule] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulesApi
     */
    public schedulesPartialUpdate(uuid: string, patchedSchedule?: PatchedSchedule, options?: AxiosRequestConfig) {
        return SchedulesApiFp(this.configuration).schedulesPartialUpdate(uuid, patchedSchedule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Schedule used in experiments which generate Files and their Datasets.         
     * @summary View specific Schedule
     * @param {string} uuid A UUID string identifying this schedule.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulesApi
     */
    public schedulesRetrieve(uuid: string, options?: AxiosRequestConfig) {
        return SchedulesApiFp(this.configuration).schedulesRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Schedules can be attached to Cycler Tests and used to view Cycler Tests which have used similar equipment.
     * @param {string} uuid A UUID string identifying this schedule.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulesApi
     */
    public schedulesWithValidationRetrieve(uuid: string, options?: AxiosRequestConfig) {
        return SchedulesApiFp(this.configuration).schedulesWithValidationRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TeamsApi - axios parameter creator
 * @export
 */
export const TeamsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Teams are groups of Users who share Resources. 
         * @summary Create a new Lab
         * @param {Team} team 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsCreate: async (team: Team, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'team' is not null or undefined
            assertParamExists('teamsCreate', 'team', team)
            const localVarPath = `/teams/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(team, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this team.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('teamsDestroy', 'id', id)
            const localVarPath = `/teams/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Teams are groups of Users who share Resources. 
         * @summary View all Labs
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsList: async (limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/teams/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Teams are groups of Users who share Resources. 
         * @summary Update a Lab
         * @param {number} id A unique integer value identifying this team.
         * @param {PatchedTeam} [patchedTeam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsPartialUpdate: async (id: number, patchedTeam?: PatchedTeam, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('teamsPartialUpdate', 'id', id)
            const localVarPath = `/teams/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedTeam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Teams are groups of Users who share Resources. 
         * @summary View a single Lab
         * @param {number} id A unique integer value identifying this team.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('teamsRetrieve', 'id', id)
            const localVarPath = `/teams/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamsApi - functional programming interface
 * @export
 */
export const TeamsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TeamsApiAxiosParamCreator(configuration)
    return {
        /**
         *  Teams are groups of Users who share Resources. 
         * @summary Create a new Lab
         * @param {Team} team 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamsCreate(team: Team, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Team>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamsCreate(team, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this team.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamsDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamsDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Teams are groups of Users who share Resources. 
         * @summary View all Labs
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamsList(limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedTeamList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamsList(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Teams are groups of Users who share Resources. 
         * @summary Update a Lab
         * @param {number} id A unique integer value identifying this team.
         * @param {PatchedTeam} [patchedTeam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamsPartialUpdate(id: number, patchedTeam?: PatchedTeam, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Team>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamsPartialUpdate(id, patchedTeam, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Teams are groups of Users who share Resources. 
         * @summary View a single Lab
         * @param {number} id A unique integer value identifying this team.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamsRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Team>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TeamsApi - factory interface
 * @export
 */
export const TeamsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TeamsApiFp(configuration)
    return {
        /**
         *  Teams are groups of Users who share Resources. 
         * @summary Create a new Lab
         * @param {Team} team 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsCreate(team: Team, options?: any): AxiosPromise<Team> {
            return localVarFp.teamsCreate(team, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this team.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.teamsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Teams are groups of Users who share Resources. 
         * @summary View all Labs
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsList(limit?: number, offset?: number, options?: any): AxiosPromise<PaginatedTeamList> {
            return localVarFp.teamsList(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         *  Teams are groups of Users who share Resources. 
         * @summary Update a Lab
         * @param {number} id A unique integer value identifying this team.
         * @param {PatchedTeam} [patchedTeam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsPartialUpdate(id: number, patchedTeam?: PatchedTeam, options?: any): AxiosPromise<Team> {
            return localVarFp.teamsPartialUpdate(id, patchedTeam, options).then((request) => request(axios, basePath));
        },
        /**
         *  Teams are groups of Users who share Resources. 
         * @summary View a single Lab
         * @param {number} id A unique integer value identifying this team.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsRetrieve(id: number, options?: any): AxiosPromise<Team> {
            return localVarFp.teamsRetrieve(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TeamsApi - object-oriented interface
 * @export
 * @class TeamsApi
 * @extends {BaseAPI}
 */
export class TeamsApi extends BaseAPI {
    /**
     *  Teams are groups of Users who share Resources. 
     * @summary Create a new Lab
     * @param {Team} team 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamsCreate(team: Team, options?: AxiosRequestConfig) {
        return TeamsApiFp(this.configuration).teamsCreate(team, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this team.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamsDestroy(id: number, options?: AxiosRequestConfig) {
        return TeamsApiFp(this.configuration).teamsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Teams are groups of Users who share Resources. 
     * @summary View all Labs
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamsList(limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return TeamsApiFp(this.configuration).teamsList(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Teams are groups of Users who share Resources. 
     * @summary Update a Lab
     * @param {number} id A unique integer value identifying this team.
     * @param {PatchedTeam} [patchedTeam] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamsPartialUpdate(id: number, patchedTeam?: PatchedTeam, options?: AxiosRequestConfig) {
        return TeamsApiFp(this.configuration).teamsPartialUpdate(id, patchedTeam, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Teams are groups of Users who share Resources. 
     * @summary View a single Lab
     * @param {number} id A unique integer value identifying this team.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamsRetrieve(id: number, options?: AxiosRequestConfig) {
        return TeamsApiFp(this.configuration).teamsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TokensApi - axios parameter creator
 * @export
 */
export const TokensApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Revoking a token renders that token invalid for authenticating requests to the API. If you have tokens that are no longer needed, or that have been leaked (for example by being included in a public Git Repository), you can should revoke them so that other people cannot use them to access the API under your credentials.         
         * @summary Revoke a token associated with your account.
         * @param {number} id A unique integer value identifying this knox auth token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tokensDestroy', 'id', id)
            const localVarPath = `/tokens/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  List all API tokens associated with this user account. You will not be able to see the value of the tokens themselves, because these values are encrypted, but you can see the names you gave them and their expiry dates.  New Tokens cannot be created at this endpoint, use /create_token/ instead.         
         * @summary View tokens associated with your account.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensList: async (limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tokens/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Token values and expiry dates are immutable, but you can change the name you associated with a token.         
         * @summary Change the name of a token associated with your account.
         * @param {number} id A unique integer value identifying this knox auth token.
         * @param {PatchedKnoxToken} [patchedKnoxToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensPartialUpdate: async (id: number, patchedKnoxToken?: PatchedKnoxToken, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tokensPartialUpdate', 'id', id)
            const localVarPath = `/tokens/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedKnoxToken, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  You will not be able to see the value of the token, but you can see the name you gave it and its creation/expiry date.         
         * @summary View a token associated with your account.
         * @param {number} id A unique integer value identifying this knox auth token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tokensRetrieve', 'id', id)
            const localVarPath = `/tokens/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TokensApi - functional programming interface
 * @export
 */
export const TokensApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TokensApiAxiosParamCreator(configuration)
    return {
        /**
         *  Revoking a token renders that token invalid for authenticating requests to the API. If you have tokens that are no longer needed, or that have been leaked (for example by being included in a public Git Repository), you can should revoke them so that other people cannot use them to access the API under your credentials.         
         * @summary Revoke a token associated with your account.
         * @param {number} id A unique integer value identifying this knox auth token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokensDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokensDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  List all API tokens associated with this user account. You will not be able to see the value of the tokens themselves, because these values are encrypted, but you can see the names you gave them and their expiry dates.  New Tokens cannot be created at this endpoint, use /create_token/ instead.         
         * @summary View tokens associated with your account.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokensList(limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedKnoxTokenList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokensList(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Token values and expiry dates are immutable, but you can change the name you associated with a token.         
         * @summary Change the name of a token associated with your account.
         * @param {number} id A unique integer value identifying this knox auth token.
         * @param {PatchedKnoxToken} [patchedKnoxToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokensPartialUpdate(id: number, patchedKnoxToken?: PatchedKnoxToken, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KnoxToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokensPartialUpdate(id, patchedKnoxToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  You will not be able to see the value of the token, but you can see the name you gave it and its creation/expiry date.         
         * @summary View a token associated with your account.
         * @param {number} id A unique integer value identifying this knox auth token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokensRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KnoxToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokensRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TokensApi - factory interface
 * @export
 */
export const TokensApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TokensApiFp(configuration)
    return {
        /**
         *  Revoking a token renders that token invalid for authenticating requests to the API. If you have tokens that are no longer needed, or that have been leaked (for example by being included in a public Git Repository), you can should revoke them so that other people cannot use them to access the API under your credentials.         
         * @summary Revoke a token associated with your account.
         * @param {number} id A unique integer value identifying this knox auth token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.tokensDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  List all API tokens associated with this user account. You will not be able to see the value of the tokens themselves, because these values are encrypted, but you can see the names you gave them and their expiry dates.  New Tokens cannot be created at this endpoint, use /create_token/ instead.         
         * @summary View tokens associated with your account.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensList(limit?: number, offset?: number, options?: any): AxiosPromise<PaginatedKnoxTokenList> {
            return localVarFp.tokensList(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         *  Token values and expiry dates are immutable, but you can change the name you associated with a token.         
         * @summary Change the name of a token associated with your account.
         * @param {number} id A unique integer value identifying this knox auth token.
         * @param {PatchedKnoxToken} [patchedKnoxToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensPartialUpdate(id: number, patchedKnoxToken?: PatchedKnoxToken, options?: any): AxiosPromise<KnoxToken> {
            return localVarFp.tokensPartialUpdate(id, patchedKnoxToken, options).then((request) => request(axios, basePath));
        },
        /**
         *  You will not be able to see the value of the token, but you can see the name you gave it and its creation/expiry date.         
         * @summary View a token associated with your account.
         * @param {number} id A unique integer value identifying this knox auth token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensRetrieve(id: number, options?: any): AxiosPromise<KnoxToken> {
            return localVarFp.tokensRetrieve(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TokensApi - object-oriented interface
 * @export
 * @class TokensApi
 * @extends {BaseAPI}
 */
export class TokensApi extends BaseAPI {
    /**
     *  Revoking a token renders that token invalid for authenticating requests to the API. If you have tokens that are no longer needed, or that have been leaked (for example by being included in a public Git Repository), you can should revoke them so that other people cannot use them to access the API under your credentials.         
     * @summary Revoke a token associated with your account.
     * @param {number} id A unique integer value identifying this knox auth token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    public tokensDestroy(id: number, options?: AxiosRequestConfig) {
        return TokensApiFp(this.configuration).tokensDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  List all API tokens associated with this user account. You will not be able to see the value of the tokens themselves, because these values are encrypted, but you can see the names you gave them and their expiry dates.  New Tokens cannot be created at this endpoint, use /create_token/ instead.         
     * @summary View tokens associated with your account.
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    public tokensList(limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return TokensApiFp(this.configuration).tokensList(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Token values and expiry dates are immutable, but you can change the name you associated with a token.         
     * @summary Change the name of a token associated with your account.
     * @param {number} id A unique integer value identifying this knox auth token.
     * @param {PatchedKnoxToken} [patchedKnoxToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    public tokensPartialUpdate(id: number, patchedKnoxToken?: PatchedKnoxToken, options?: AxiosRequestConfig) {
        return TokensApiFp(this.configuration).tokensPartialUpdate(id, patchedKnoxToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  You will not be able to see the value of the token, but you can see the name you gave it and its creation/expiry date.         
     * @summary View a token associated with your account.
     * @param {number} id A unique integer value identifying this knox auth token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    public tokensRetrieve(id: number, options?: AxiosRequestConfig) {
        return TokensApiFp(this.configuration).tokensRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UnitsApi - axios parameter creator
 * @export
 */
export const UnitsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Units are scientific (typically SI) units which describe how data map to quantities in the world. Some Units are predefined (e.g. seconds, volts, amps, unitless quantities), while others can be defined in experimental data.  Searchable fields: - name - symbol - description         
         * @summary View Units
         * @param {boolean} [isDefault] 
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unitsList: async (isDefault?: boolean, limit?: number, name?: string, offset?: number, symbol?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/units/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (isDefault !== undefined) {
                localVarQueryParameter['is_default'] = isDefault;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Units are scientific (typically SI) units which describe how data map to quantities in the world. Some Units are predefined (e.g. seconds, volts, amps, unitless quantities), while others can be defined in experimental data.         
         * @summary View a Unit
         * @param {number} id A unique integer value identifying this data unit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unitsRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('unitsRetrieve', 'id', id)
            const localVarPath = `/units/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UnitsApi - functional programming interface
 * @export
 */
export const UnitsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UnitsApiAxiosParamCreator(configuration)
    return {
        /**
         *  Units are scientific (typically SI) units which describe how data map to quantities in the world. Some Units are predefined (e.g. seconds, volts, amps, unitless quantities), while others can be defined in experimental data.  Searchable fields: - name - symbol - description         
         * @summary View Units
         * @param {boolean} [isDefault] 
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unitsList(isDefault?: boolean, limit?: number, name?: string, offset?: number, symbol?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedDataUnitList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unitsList(isDefault, limit, name, offset, symbol, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Units are scientific (typically SI) units which describe how data map to quantities in the world. Some Units are predefined (e.g. seconds, volts, amps, unitless quantities), while others can be defined in experimental data.         
         * @summary View a Unit
         * @param {number} id A unique integer value identifying this data unit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unitsRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataUnit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unitsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UnitsApi - factory interface
 * @export
 */
export const UnitsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UnitsApiFp(configuration)
    return {
        /**
         *  Units are scientific (typically SI) units which describe how data map to quantities in the world. Some Units are predefined (e.g. seconds, volts, amps, unitless quantities), while others can be defined in experimental data.  Searchable fields: - name - symbol - description         
         * @summary View Units
         * @param {boolean} [isDefault] 
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unitsList(isDefault?: boolean, limit?: number, name?: string, offset?: number, symbol?: string, options?: any): AxiosPromise<PaginatedDataUnitList> {
            return localVarFp.unitsList(isDefault, limit, name, offset, symbol, options).then((request) => request(axios, basePath));
        },
        /**
         *  Units are scientific (typically SI) units which describe how data map to quantities in the world. Some Units are predefined (e.g. seconds, volts, amps, unitless quantities), while others can be defined in experimental data.         
         * @summary View a Unit
         * @param {number} id A unique integer value identifying this data unit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unitsRetrieve(id: number, options?: any): AxiosPromise<DataUnit> {
            return localVarFp.unitsRetrieve(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UnitsApi - object-oriented interface
 * @export
 * @class UnitsApi
 * @extends {BaseAPI}
 */
export class UnitsApi extends BaseAPI {
    /**
     *  Units are scientific (typically SI) units which describe how data map to quantities in the world. Some Units are predefined (e.g. seconds, volts, amps, unitless quantities), while others can be defined in experimental data.  Searchable fields: - name - symbol - description         
     * @summary View Units
     * @param {boolean} [isDefault] 
     * @param {number} [limit] Number of results to return per page.
     * @param {string} [name] 
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [symbol] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitsApi
     */
    public unitsList(isDefault?: boolean, limit?: number, name?: string, offset?: number, symbol?: string, options?: AxiosRequestConfig) {
        return UnitsApiFp(this.configuration).unitsList(isDefault, limit, name, offset, symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Units are scientific (typically SI) units which describe how data map to quantities in the world. Some Units are predefined (e.g. seconds, volts, amps, unitless quantities), while others can be defined in experimental data.         
     * @summary View a Unit
     * @param {number} id A unique integer value identifying this data unit.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitsApi
     */
    public unitsRetrieve(id: number, options?: AxiosRequestConfig) {
        return UnitsApiFp(this.configuration).unitsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Users are Django User instances custom-serialized for convenience.
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCreate: async (user: User, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('usersCreate', 'user', user)
            const localVarPath = `/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Users are Django User instances custom-serialized for convenience.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersList: async (limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Your User profile can be updated. You may change your email address and password. All changes require your current password to be accepted.         
         * @summary Update User profile
         * @param {number} id A unique integer value identifying this user proxy.
         * @param {PatchedUserUpdate} [patchedUserUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPartialUpdate: async (id: number, patchedUserUpdate?: PatchedUserUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersPartialUpdate', 'id', id)
            const localVarPath = `/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedUserUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Users are Django User instances custom-serialized for convenience.
         * @param {number} id A unique integer value identifying this user proxy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersRetrieve', 'id', id)
            const localVarPath = `/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Users are Django User instances custom-serialized for convenience.
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersCreate(user: User, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersCreate(user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Users are Django User instances custom-serialized for convenience.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersList(limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedUserList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersList(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Your User profile can be updated. You may change your email address and password. All changes require your current password to be accepted.         
         * @summary Update User profile
         * @param {number} id A unique integer value identifying this user proxy.
         * @param {PatchedUserUpdate} [patchedUserUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPartialUpdate(id: number, patchedUserUpdate?: PatchedUserUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPartialUpdate(id, patchedUserUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Users are Django User instances custom-serialized for convenience.
         * @param {number} id A unique integer value identifying this user proxy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Users are Django User instances custom-serialized for convenience.
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCreate(user: User, options?: any): AxiosPromise<User> {
            return localVarFp.usersCreate(user, options).then((request) => request(axios, basePath));
        },
        /**
         * Users are Django User instances custom-serialized for convenience.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersList(limit?: number, offset?: number, options?: any): AxiosPromise<PaginatedUserList> {
            return localVarFp.usersList(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         *  Your User profile can be updated. You may change your email address and password. All changes require your current password to be accepted.         
         * @summary Update User profile
         * @param {number} id A unique integer value identifying this user proxy.
         * @param {PatchedUserUpdate} [patchedUserUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPartialUpdate(id: number, patchedUserUpdate?: PatchedUserUpdate, options?: any): AxiosPromise<User> {
            return localVarFp.usersPartialUpdate(id, patchedUserUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Users are Django User instances custom-serialized for convenience.
         * @param {number} id A unique integer value identifying this user proxy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersRetrieve(id: number, options?: any): AxiosPromise<User> {
            return localVarFp.usersRetrieve(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Users are Django User instances custom-serialized for convenience.
     * @param {User} user 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersCreate(user: User, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersCreate(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Users are Django User instances custom-serialized for convenience.
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersList(limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersList(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Your User profile can be updated. You may change your email address and password. All changes require your current password to be accepted.         
     * @summary Update User profile
     * @param {number} id A unique integer value identifying this user proxy.
     * @param {PatchedUserUpdate} [patchedUserUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersPartialUpdate(id: number, patchedUserUpdate?: PatchedUserUpdate, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersPartialUpdate(id, patchedUserUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Users are Django User instances custom-serialized for convenience.
     * @param {number} id A unique integer value identifying this user proxy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersRetrieve(id: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ValidationSchemasApi - axios parameter creator
 * @export
 */
export const ValidationSchemasApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ValidationSchema} validationSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validationSchemasCreate: async (validationSchema: ValidationSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'validationSchema' is not null or undefined
            assertParamExists('validationSchemasCreate', 'validationSchema', validationSchema)
            const localVarPath = `/validation_schemas/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(validationSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uuid A UUID string identifying this validation schema.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validationSchemasDestroy: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('validationSchemasDestroy', 'uuid', uuid)
            const localVarPath = `/validation_schemas/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Validation schemas contain one or more root properties that describe requirements for Galv objects. This endpoint provides the names and list URLs for each Galv object that can be validated against a schema.         
         * @summary Keys available for validation schemas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validationSchemasKeysRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/validation_schemas/keys/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Validation schemas contain one or more definitions that describe requirements for Galv objects. The possible values are available at `/keys/` and should be implemented in your schema thus:  ```json {     ...     \"$defs\": {         \"key_name\": {             ... description         },         ... and so on for any other keys     },     ... ```  For each of these schemas that is enabled, Galv will test the objects against the definition by constructing a JSON Schema file that hooks in your definitions and asserts a single object. This means you need not specify a root object (e.g. with `\"type\": \"object\"`) in your schema.  ```json {     ...     \"type\": {\"$ref\": \"#/$defs/key_name\"} } ```  Because your definitions are included locally, you can include references to other definitions in your schema,  and Galv will automatically resolve them for you.  Galv will highlight any objects that do not meet the requirements. This can allow you to specify a series of increasingly strict requirements for your lab\'s metadata.  Schemas are validated against _individually_, and are not checked for consistency. If you declare that a particular field is a `string` in one schema and a `number` in another,  Galv will not complain, except to issue a warning for failing to adhere to one or the other schema.  Because schemas validate objects returned from the Galv API,  schemas should expect most relational fields to be represented as URLs.   Note: there are some requirements put in place by Galv\'s database structure.  These will always apply, and will generate errors rather than warnings. 
         * @summary List all Validation Schemas
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validationSchemasList: async (limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/validation_schemas/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uuid A UUID string identifying this validation schema.
         * @param {PatchedValidationSchema} [patchedValidationSchema] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validationSchemasPartialUpdate: async (uuid: string, patchedValidationSchema?: PatchedValidationSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('validationSchemasPartialUpdate', 'uuid', uuid)
            const localVarPath = `/validation_schemas/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedValidationSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uuid A UUID string identifying this validation schema.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validationSchemasRetrieve: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('validationSchemasRetrieve', 'uuid', uuid)
            const localVarPath = `/validation_schemas/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uuid A UUID string identifying this validation schema.
         * @param {ValidationSchema} validationSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validationSchemasUpdate: async (uuid: string, validationSchema: ValidationSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('validationSchemasUpdate', 'uuid', uuid)
            // verify required parameter 'validationSchema' is not null or undefined
            assertParamExists('validationSchemasUpdate', 'validationSchema', validationSchema)
            const localVarPath = `/validation_schemas/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication knoxTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(validationSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ValidationSchemasApi - functional programming interface
 * @export
 */
export const ValidationSchemasApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ValidationSchemasApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ValidationSchema} validationSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validationSchemasCreate(validationSchema: ValidationSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidationSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validationSchemasCreate(validationSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} uuid A UUID string identifying this validation schema.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validationSchemasDestroy(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validationSchemasDestroy(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Validation schemas contain one or more root properties that describe requirements for Galv objects. This endpoint provides the names and list URLs for each Galv object that can be validated against a schema.         
         * @summary Keys available for validation schemas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validationSchemasKeysRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidationSchemaRootKeys>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validationSchemasKeysRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Validation schemas contain one or more definitions that describe requirements for Galv objects. The possible values are available at `/keys/` and should be implemented in your schema thus:  ```json {     ...     \"$defs\": {         \"key_name\": {             ... description         },         ... and so on for any other keys     },     ... ```  For each of these schemas that is enabled, Galv will test the objects against the definition by constructing a JSON Schema file that hooks in your definitions and asserts a single object. This means you need not specify a root object (e.g. with `\"type\": \"object\"`) in your schema.  ```json {     ...     \"type\": {\"$ref\": \"#/$defs/key_name\"} } ```  Because your definitions are included locally, you can include references to other definitions in your schema,  and Galv will automatically resolve them for you.  Galv will highlight any objects that do not meet the requirements. This can allow you to specify a series of increasingly strict requirements for your lab\'s metadata.  Schemas are validated against _individually_, and are not checked for consistency. If you declare that a particular field is a `string` in one schema and a `number` in another,  Galv will not complain, except to issue a warning for failing to adhere to one or the other schema.  Because schemas validate objects returned from the Galv API,  schemas should expect most relational fields to be represented as URLs.   Note: there are some requirements put in place by Galv\'s database structure.  These will always apply, and will generate errors rather than warnings. 
         * @summary List all Validation Schemas
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validationSchemasList(limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedValidationSchemaList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validationSchemasList(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} uuid A UUID string identifying this validation schema.
         * @param {PatchedValidationSchema} [patchedValidationSchema] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validationSchemasPartialUpdate(uuid: string, patchedValidationSchema?: PatchedValidationSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidationSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validationSchemasPartialUpdate(uuid, patchedValidationSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} uuid A UUID string identifying this validation schema.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validationSchemasRetrieve(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidationSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validationSchemasRetrieve(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} uuid A UUID string identifying this validation schema.
         * @param {ValidationSchema} validationSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validationSchemasUpdate(uuid: string, validationSchema: ValidationSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidationSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validationSchemasUpdate(uuid, validationSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ValidationSchemasApi - factory interface
 * @export
 */
export const ValidationSchemasApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ValidationSchemasApiFp(configuration)
    return {
        /**
         * 
         * @param {ValidationSchema} validationSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validationSchemasCreate(validationSchema: ValidationSchema, options?: any): AxiosPromise<ValidationSchema> {
            return localVarFp.validationSchemasCreate(validationSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uuid A UUID string identifying this validation schema.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validationSchemasDestroy(uuid: string, options?: any): AxiosPromise<void> {
            return localVarFp.validationSchemasDestroy(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         *  Validation schemas contain one or more root properties that describe requirements for Galv objects. This endpoint provides the names and list URLs for each Galv object that can be validated against a schema.         
         * @summary Keys available for validation schemas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validationSchemasKeysRetrieve(options?: any): AxiosPromise<ValidationSchemaRootKeys> {
            return localVarFp.validationSchemasKeysRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         *  Validation schemas contain one or more definitions that describe requirements for Galv objects. The possible values are available at `/keys/` and should be implemented in your schema thus:  ```json {     ...     \"$defs\": {         \"key_name\": {             ... description         },         ... and so on for any other keys     },     ... ```  For each of these schemas that is enabled, Galv will test the objects against the definition by constructing a JSON Schema file that hooks in your definitions and asserts a single object. This means you need not specify a root object (e.g. with `\"type\": \"object\"`) in your schema.  ```json {     ...     \"type\": {\"$ref\": \"#/$defs/key_name\"} } ```  Because your definitions are included locally, you can include references to other definitions in your schema,  and Galv will automatically resolve them for you.  Galv will highlight any objects that do not meet the requirements. This can allow you to specify a series of increasingly strict requirements for your lab\'s metadata.  Schemas are validated against _individually_, and are not checked for consistency. If you declare that a particular field is a `string` in one schema and a `number` in another,  Galv will not complain, except to issue a warning for failing to adhere to one or the other schema.  Because schemas validate objects returned from the Galv API,  schemas should expect most relational fields to be represented as URLs.   Note: there are some requirements put in place by Galv\'s database structure.  These will always apply, and will generate errors rather than warnings. 
         * @summary List all Validation Schemas
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validationSchemasList(limit?: number, offset?: number, options?: any): AxiosPromise<PaginatedValidationSchemaList> {
            return localVarFp.validationSchemasList(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uuid A UUID string identifying this validation schema.
         * @param {PatchedValidationSchema} [patchedValidationSchema] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validationSchemasPartialUpdate(uuid: string, patchedValidationSchema?: PatchedValidationSchema, options?: any): AxiosPromise<ValidationSchema> {
            return localVarFp.validationSchemasPartialUpdate(uuid, patchedValidationSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uuid A UUID string identifying this validation schema.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validationSchemasRetrieve(uuid: string, options?: any): AxiosPromise<ValidationSchema> {
            return localVarFp.validationSchemasRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uuid A UUID string identifying this validation schema.
         * @param {ValidationSchema} validationSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validationSchemasUpdate(uuid: string, validationSchema: ValidationSchema, options?: any): AxiosPromise<ValidationSchema> {
            return localVarFp.validationSchemasUpdate(uuid, validationSchema, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ValidationSchemasApi - object-oriented interface
 * @export
 * @class ValidationSchemasApi
 * @extends {BaseAPI}
 */
export class ValidationSchemasApi extends BaseAPI {
    /**
     * 
     * @param {ValidationSchema} validationSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidationSchemasApi
     */
    public validationSchemasCreate(validationSchema: ValidationSchema, options?: AxiosRequestConfig) {
        return ValidationSchemasApiFp(this.configuration).validationSchemasCreate(validationSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uuid A UUID string identifying this validation schema.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidationSchemasApi
     */
    public validationSchemasDestroy(uuid: string, options?: AxiosRequestConfig) {
        return ValidationSchemasApiFp(this.configuration).validationSchemasDestroy(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Validation schemas contain one or more root properties that describe requirements for Galv objects. This endpoint provides the names and list URLs for each Galv object that can be validated against a schema.         
     * @summary Keys available for validation schemas
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidationSchemasApi
     */
    public validationSchemasKeysRetrieve(options?: AxiosRequestConfig) {
        return ValidationSchemasApiFp(this.configuration).validationSchemasKeysRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Validation schemas contain one or more definitions that describe requirements for Galv objects. The possible values are available at `/keys/` and should be implemented in your schema thus:  ```json {     ...     \"$defs\": {         \"key_name\": {             ... description         },         ... and so on for any other keys     },     ... ```  For each of these schemas that is enabled, Galv will test the objects against the definition by constructing a JSON Schema file that hooks in your definitions and asserts a single object. This means you need not specify a root object (e.g. with `\"type\": \"object\"`) in your schema.  ```json {     ...     \"type\": {\"$ref\": \"#/$defs/key_name\"} } ```  Because your definitions are included locally, you can include references to other definitions in your schema,  and Galv will automatically resolve them for you.  Galv will highlight any objects that do not meet the requirements. This can allow you to specify a series of increasingly strict requirements for your lab\'s metadata.  Schemas are validated against _individually_, and are not checked for consistency. If you declare that a particular field is a `string` in one schema and a `number` in another,  Galv will not complain, except to issue a warning for failing to adhere to one or the other schema.  Because schemas validate objects returned from the Galv API,  schemas should expect most relational fields to be represented as URLs.   Note: there are some requirements put in place by Galv\'s database structure.  These will always apply, and will generate errors rather than warnings. 
     * @summary List all Validation Schemas
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidationSchemasApi
     */
    public validationSchemasList(limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return ValidationSchemasApiFp(this.configuration).validationSchemasList(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uuid A UUID string identifying this validation schema.
     * @param {PatchedValidationSchema} [patchedValidationSchema] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidationSchemasApi
     */
    public validationSchemasPartialUpdate(uuid: string, patchedValidationSchema?: PatchedValidationSchema, options?: AxiosRequestConfig) {
        return ValidationSchemasApiFp(this.configuration).validationSchemasPartialUpdate(uuid, patchedValidationSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uuid A UUID string identifying this validation schema.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidationSchemasApi
     */
    public validationSchemasRetrieve(uuid: string, options?: AxiosRequestConfig) {
        return ValidationSchemasApiFp(this.configuration).validationSchemasRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uuid A UUID string identifying this validation schema.
     * @param {ValidationSchema} validationSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidationSchemasApi
     */
    public validationSchemasUpdate(uuid: string, validationSchema: ValidationSchema, options?: AxiosRequestConfig) {
        return ValidationSchemasApiFp(this.configuration).validationSchemasUpdate(uuid, validationSchema, options).then((request) => request(this.axios, this.basePath));
    }
}


